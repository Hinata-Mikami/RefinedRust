{"$message_type":"diagnostic","message":"dereference of raw pointer is unsafe and requires unsafe block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `warn` by default in the 2024 edition and `allow` by default in earlier\neditions.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":2306,"byte_end":2313,"line_start":69,"line_end":69,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"            (*node).next = next;","highlight_start":13,"highlight_end":20}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"an unsafe function restricts its caller, but its body is safe by default","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":2133,"byte_end":2192,"line_start":67,"line_end":67,"column_start":5,"column_end":64,"is_primary":true,"text":[{"text":"    unsafe fn set_next(&self, node: *mut Node, next: *mut Node) {","highlight_start":5,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`#[warn(unsafe_op_in_unsafe_fn)]` (part of `#[warn(rust_2024_compatibility)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider wrapping the function body in an unsafe block","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2193,"byte_end":2193,"line_start":67,"line_end":67,"column_start":65,"column_end":65,"is_primary":true,"text":[{"text":"    unsafe fn set_next(&self, node: *mut Node, next: *mut Node) {","highlight_start":65,"highlight_end":65}],"label":null,"suggested_replacement":"{ unsafe ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":2342,"byte_end":2342,"line_start":71,"line_end":71,"column_start":6,"column_end":6,"is_primary":true,"text":[{"text":"    }","highlight_start":6,"highlight_end":6}],"label":null,"suggested_replacement":"}","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning[E0133]\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe block\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:69:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             (*node).next = next;\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[33m^^^^^^^\u001b[0m \u001b[1m\u001b[33mdereference of raw pointer\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n\u001b[1m\u001b[92mnote\u001b[0m: an unsafe function restricts its caller, but its body is safe by default\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:67:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     unsafe fn set_next(&self, node: *mut Node, next: *mut Node) {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unsafe_op_in_unsafe_fn)]` (part of `#[warn(rust_2024_compatibility)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"dereference of raw pointer is unsafe and requires unsafe block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `warn` by default in the 2024 edition and `allow` by default in earlier\neditions.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":2549,"byte_end":2562,"line_start":76,"line_end":76,"column_start":36,"column_end":49,"is_primary":true,"text":[{"text":"        if start_node.is_null() || (*start_node).marked {","highlight_start":36,"highlight_end":49}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"an unsafe function restricts its caller, but its body is safe by default","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":2380,"byte_end":2424,"line_start":74,"line_end":74,"column_start":5,"column_end":49,"is_primary":true,"text":[{"text":"    unsafe fn mark(&self, start_node: *mut Node) {","highlight_start":5,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider wrapping the function body in an unsafe block","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2425,"byte_end":2425,"line_start":74,"line_end":74,"column_start":50,"column_end":50,"is_primary":true,"text":[{"text":"    unsafe fn mark(&self, start_node: *mut Node) {","highlight_start":50,"highlight_end":50}],"label":null,"suggested_replacement":"{ unsafe ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":2728,"byte_end":2728,"line_start":82,"line_end":82,"column_start":6,"column_end":6,"is_primary":true,"text":[{"text":"    }","highlight_start":6,"highlight_end":6}],"label":null,"suggested_replacement":"}","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning[E0133]\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe block\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:76:36\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if start_node.is_null() || (*start_node).marked {\n   \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mdereference of raw pointer\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n\u001b[1m\u001b[92mnote\u001b[0m: an unsafe function restricts its caller, but its body is safe by default\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:74:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     unsafe fn mark(&self, start_node: *mut Node) {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"dereference of raw pointer is unsafe and requires unsafe block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `warn` by default in the 2024 edition and `allow` by default in earlier\neditions.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":2611,"byte_end":2624,"line_start":80,"line_end":80,"column_start":9,"column_end":22,"is_primary":true,"text":[{"text":"        (*start_node).marked = true;","highlight_start":9,"highlight_end":22}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning[E0133]\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe block\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:80:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         (*start_node).marked = true;\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mdereference of raw pointer\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n\n"}
{"$message_type":"diagnostic","message":"call to unsafe function `LinkedList::mark` is unsafe and requires unsafe block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `warn` by default in the 2024 edition and `allow` by default in earlier\neditions.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":2648,"byte_end":2677,"line_start":81,"line_end":81,"column_start":9,"column_end":38,"is_primary":true,"text":[{"text":"        self.mark((*start_node).next);  // 再帰的に次のノードもマーク","highlight_start":9,"highlight_end":38}],"label":"call to unsafe function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consult the function's documentation for information on how to avoid undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning[E0133]\u001b[0m\u001b[1m: call to unsafe function `LinkedList::mark` is unsafe and requires unsafe block\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:81:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.mark((*start_node).next);  // 再帰的に次\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mcall to unsafe function\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consult the function's documentation for information on how to avoid undefined behavior\n\n"}
{"$message_type":"diagnostic","message":"dereference of raw pointer is unsafe and requires unsafe block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `warn` by default in the 2024 edition and `allow` by default in earlier\neditions.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":2658,"byte_end":2671,"line_start":81,"line_end":81,"column_start":19,"column_end":32,"is_primary":true,"text":[{"text":"        self.mark((*start_node).next);  // 再帰的に次のノードもマーク","highlight_start":19,"highlight_end":32}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning[E0133]\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe block\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:81:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m.mark((*start_node).next);  // 再帰的に次のノードも\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mdereference of raw pointer\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n\n"}
{"$message_type":"diagnostic","message":"dereference of raw pointer is unsafe and requires unsafe block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `warn` by default in the 2024 edition and `allow` by default in earlier\neditions.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":2989,"byte_end":3000,"line_start":90,"line_end":90,"column_start":16,"column_end":27,"is_primary":true,"text":[{"text":"            if (*node_ptr).marked {                 // marked==true -> 参照されているノード","highlight_start":16,"highlight_end":27}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"an unsafe function restricts its caller, but its body is safe by default","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":2770,"byte_end":2796,"line_start":86,"line_end":86,"column_start":5,"column_end":31,"is_primary":true,"text":[{"text":"    unsafe fn sweep(&mut self) {","highlight_start":5,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider wrapping the function body in an unsafe block","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2797,"byte_end":2797,"line_start":86,"line_end":86,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"    unsafe fn sweep(&mut self) {","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":"{ unsafe ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":3552,"byte_end":3552,"line_start":99,"line_end":99,"column_start":6,"column_end":6,"is_primary":true,"text":[{"text":"    }","highlight_start":6,"highlight_end":6}],"label":null,"suggested_replacement":"}","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning[E0133]\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe block\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:90:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   if (*node_ptr).marked {                 // marked\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mdereference of raw pointer\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n\u001b[1m\u001b[92mnote\u001b[0m: an unsafe function restricts its caller, but its body is safe by default\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:86:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     unsafe fn sweep(&mut self) {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"dereference of raw pointer is unsafe and requires unsafe block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `warn` by default in the 2024 edition and `allow` by default in earlier\neditions.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":3092,"byte_end":3103,"line_start":91,"line_end":91,"column_start":17,"column_end":28,"is_primary":true,"text":[{"text":"                (*node_ptr).marked = false;         // リセット","highlight_start":17,"highlight_end":28}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning[E0133]\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe block\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:91:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   (*node_ptr).marked = false;         // リセット\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mdereference of raw pointer\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n\n"}
{"$message_type":"diagnostic","message":"dereference of raw pointer is unsafe and requires unsafe block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `warn` by default in the 2024 edition and `allow` by default in earlier\neditions.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":3297,"byte_end":3308,"line_start":94,"line_end":94,"column_start":59,"column_end":70,"is_primary":true,"text":[{"text":"                println!(\"GC msg : Node [{}] collected.\", (*node_ptr).value);","highlight_start":59,"highlight_end":70}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning[E0133]\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe block\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:94:59\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m94\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mted.\", (*node_ptr).value);\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mdereference of raw pointer\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n\n"}
{"$message_type":"diagnostic","message":"call to unsafe function `std::boxed::Box::<T>::from_raw` is unsafe and requires unsafe block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `warn` by default in the 2024 edition and `allow` by default in earlier\neditions.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":3341,"byte_end":3364,"line_start":95,"line_end":95,"column_start":25,"column_end":48,"is_primary":true,"text":[{"text":"                let _ = Box::from_raw(node_ptr);    // Boxに管理させる 所有者がいないため解放される","highlight_start":25,"highlight_end":48}],"label":"call to unsafe function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consult the function's documentation for information on how to avoid undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning[E0133]\u001b[0m\u001b[1m: call to unsafe function `std::boxed::Box::<T>::from_raw` is unsafe and requires unsafe block\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:95:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m95\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m   let _ = Box::from_raw(node_ptr);    // Boxに管理\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mcall to unsafe function\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consult the function's documentation for information on how to avoid undefined behavior\n\n"}
{"$message_type":"diagnostic","message":"call to unsafe function `LinkedList::mark` is unsafe and requires unsafe block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `warn` by default in the 2024 edition and `allow` by default in earlier\neditions.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":3828,"byte_end":3843,"line_start":106,"line_end":106,"column_start":13,"column_end":28,"is_primary":true,"text":[{"text":"            self.mark(root);","highlight_start":13,"highlight_end":28}],"label":"call to unsafe function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consult the function's documentation for information on how to avoid undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"an unsafe function restricts its caller, but its body is safe by default","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":3601,"byte_end":3652,"line_start":102,"line_end":102,"column_start":5,"column_end":56,"is_primary":true,"text":[{"text":"    unsafe fn collect(&mut self, roots: Vec<*mut Node>) {","highlight_start":5,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider wrapping the function body in an unsafe block","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":3653,"byte_end":3653,"line_start":102,"line_end":102,"column_start":57,"column_end":57,"is_primary":true,"text":[{"text":"    unsafe fn collect(&mut self, roots: Vec<*mut Node>) {","highlight_start":57,"highlight_end":57}],"label":null,"suggested_replacement":"{ unsafe ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":4029,"byte_end":4029,"line_start":114,"line_end":114,"column_start":6,"column_end":6,"is_primary":true,"text":[{"text":"    }","highlight_start":6,"highlight_end":6}],"label":null,"suggested_replacement":"}","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning[E0133]\u001b[0m\u001b[1m: call to unsafe function `LinkedList::mark` is unsafe and requires unsafe block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:106:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             self.mark(root);\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mcall to unsafe function\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consult the function's documentation for information on how to avoid undefined behavior\n\u001b[1m\u001b[92mnote\u001b[0m: an unsafe function restricts its caller, but its body is safe by default\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:102:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m102\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     unsafe fn collect(&mut self, roots: Vec<*mut Node>) {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"call to unsafe function `LinkedList::sweep` is unsafe and requires unsafe block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `warn` by default in the 2024 edition and `allow` by default in earlier\neditions.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":3864,"byte_end":3876,"line_start":109,"line_end":109,"column_start":9,"column_end":21,"is_primary":true,"text":[{"text":"        self.sweep();","highlight_start":9,"highlight_end":21}],"label":"call to unsafe function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consult the function's documentation for information on how to avoid undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning[E0133]\u001b[0m\u001b[1m: call to unsafe function `LinkedList::sweep` is unsafe and requires unsafe block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:109:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m109\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.sweep();\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mcall to unsafe function\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consult the function's documentation for information on how to avoid undefined behavior\n\n"}
{"$message_type":"diagnostic","message":"dereference of raw pointer is unsafe and requires unsafe block","code":{"code":"E0133","explanation":"Unsafe code was used outside of an unsafe block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee the [unsafe section][unsafe-section] of the Book for more details.\n\n#### Unsafe code in functions\n\nUnsafe code is currently accepted in unsafe functions, but that is being phased\nout in favor of requiring unsafe blocks here too.\n\n```\nunsafe fn f() { return; }\n\nunsafe fn g() {\n    f(); // Is accepted, but no longer recommended\n    unsafe { f(); } // Recommended way to write this\n}\n```\n\nLinting against this is controlled via the `unsafe_op_in_unsafe_fn` lint, which\nis `warn` by default in the 2024 edition and `allow` by default in earlier\neditions.\n\n[unsafe-section]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n"},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":4132,"byte_end":4138,"line_start":119,"line_end":119,"column_start":29,"column_end":35,"is_primary":true,"text":[{"text":"            print!(\"[{}] \", (*ptr).value);","highlight_start":29,"highlight_end":35}],"label":"dereference of raw pointer","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"an unsafe function restricts its caller, but its body is safe by default","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":4036,"byte_end":4063,"line_start":117,"line_end":117,"column_start":5,"column_end":32,"is_primary":true,"text":[{"text":"    unsafe fn print_heap(&self) {","highlight_start":5,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider wrapping the function body in an unsafe block","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4064,"byte_end":4064,"line_start":117,"line_end":117,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"    unsafe fn print_heap(&self) {","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":"{ unsafe ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":4182,"byte_end":4182,"line_start":122,"line_end":122,"column_start":6,"column_end":6,"is_primary":true,"text":[{"text":"    }","highlight_start":6,"highlight_end":6}],"label":null,"suggested_replacement":"}","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning[E0133]\u001b[0m\u001b[1m: dereference of raw pointer is unsafe and requires unsafe block\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:119:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m119\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             print!(\"[{}] \", (*ptr).value);\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33mdereference of raw pointer\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n\u001b[1m\u001b[92mnote\u001b[0m: an unsafe function restricts its caller, but its body is safe by default\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:117:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m117\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     unsafe fn print_heap(&self) {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `n4`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":4427,"byte_end":4429,"line_start":134,"line_end":134,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"        let n4 = linkedlist.alloc(40);","highlight_start":13,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":4427,"byte_end":4429,"line_start":134,"line_end":134,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"        let n4 = linkedlist.alloc(40);","highlight_start":13,"highlight_end":15}],"label":null,"suggested_replacement":"_n4","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `n4`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:134:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m134\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let n4 = linkedlist.alloc(40);\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[33m^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_n4`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"13 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: 13 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0133`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about this error, try `rustc --explain E0133`.\u001b[0m\n"}
