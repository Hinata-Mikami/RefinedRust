Section extra_specs.
Context `{RRGS : !refinedrustGS Σ}.

Section Vec_inv_t_ne.
  Context `{!refinedrustGS Σ}.

  Global Instance Vec_inv_t_contr {rt1 T_rt A_rt} Alloc (T : type rt1 → type T_rt) (A : type A_rt) :
    TypeNonExpansive T →
    TypeContractive (λ ty, Vec_inv_t T_rt A_rt Alloc <TY> (T ty) <TY> A <INST!>).
  Proof.
  Admitted.
  Global Instance Vec_inv_t_ne {rt1 T_rt A_rt} Alloc (T : type rt1 → type T_rt) (A : type A_rt) :
    TypeNonExpansive T →
    TypeNonExpansive (λ ty, Vec_inv_t T_rt A_rt Alloc <TY> (T ty) <TY> A <INST!>).
  Proof. Admitted.
End Vec_inv_t_ne.


(* NOTE Resolution of ghost variables over the invariant -- not currently automatically generated by the frontend. *)
Lemma resolve_ghost_Vec_T_owned {T_rt : RT} (T_ty : type (T_rt)) {A_rt : RT} (A_ty : type (A_rt)) A_attrs π E L rm l rs T :
  (∀ li, resolve_ghost_iter π E L rm false li (ty_syn_type T_ty MetaNone) (replicate (length rs) (◁ T_ty))%I (Owned ) rs [] 0%nat (λ L2 rs' R progress,
    T L2 (#rs') R progress)) ⊢
  resolve_ghost π E L rm true l (◁ (Vec_inv_t T_rt A_rt A_attrs <TY> T_ty <TY> A_ty <INST!>)) (Owned ) (#rs) T.
Proof.
Admitted.
Definition resolve_ghost_Vec_T_owned_inst := [instance @resolve_ghost_Vec_T_owned].
Global Existing Instance resolve_ghost_Vec_T_owned_inst.

Lemma resolve_ghost_Vec_T_uniq {T_rt : RT} (T_ty : type (T_rt)) {A_rt : RT} (A_ty : type (A_rt)) A_attrs π E L rm l rs κ γ T :
  ⌜lctx_lft_alive E L κ⌝ ∗
  (∀ li, resolve_ghost_iter π E L rm false li (ty_syn_type T_ty MetaNone) (replicate (length rs) (◁ T_ty))%I (Owned ) rs [] 0%nat (λ L2 rs' R progress,
    T L2 (#rs') R progress)) ⊢
  resolve_ghost π E L rm true l (◁ (Vec_inv_t T_rt A_rt A_attrs <TY> T_ty <TY> A_ty <INST!>)) (Uniq κ γ) (#rs) T.
Proof.
Admitted.
Definition resolve_ghost_Vec_T_uniq_inst := [instance @resolve_ghost_Vec_T_uniq].
Global Existing Instance resolve_ghost_Vec_T_uniq_inst.

Global Program Instance iterator_learn_vec_intoiter_it T_rt A_rt A_attrs :
  IteratorLearnInductive (IntoIterTAasstd_iter_Iterator_spec_attrs T_rt A_rt A_attrs) :=
  {| iterator_learn_inductive_Q s1 hist s2 := s1 = hist ++ s2 |}.
Next Obligation.
  iIntros (???????) "Hx".
  iPoseProof (boringly_persistent_elim with "Hx") as "Hx".
  iInduction hist as [ | x hist] "IH" forall (s1 s2); simpl.
  { iDestruct "Hx" as "->". iPureIntro. done. }
  iDestruct "Hx" as "(%s1' & (_ & ->) & Hx)".
  iPoseProof ("IH" with "Hx") as "->".
  done.
Qed.

Global Program Instance iterator_learn_learn_slice_iter T_rt :
  IteratorLearnInductive (IteraTasstd_iter_Iterator_spec_attrs T_rt) :=
  {| iterator_learn_inductive_Q s1 hist s2 := s1 = hist ++ s2 |}.
Next Obligation.
  iIntros (?????) "Hx".
  iPoseProof (boringly_persistent_elim with "Hx") as "Hx".
  iInduction hist as [ | x hist] "IH" forall (s1 s2); simpl.
  { iDestruct "Hx" as "->". iPureIntro. done. }
  iDestruct "Hx" as "(%s1' & (_ & ->) & Hx)".
  iPoseProof ("IH" with "Hx") as "->".
  done.
Qed.

End extra_specs.
