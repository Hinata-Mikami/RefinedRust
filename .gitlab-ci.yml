stages: [ nix-cache, lint, build, tests ]

.upstream_only: &upstream_only
  rules:
    - if: $CI_PROJECT_PATH == "lgaeher/refinedrust-dev" && $CI_PIPELINE_SOURCE != "merge_request_event"

.forks_only: &forks_only
  rules:
    - if: $CI_PROJECT_PATH != "lgaeher/refinedrust-dev"


# Nix jobs expects two variables: `NIX_CI_CACHE_PUB_KEY` and `NIX_CI_CACHE_PRIV_KEY` (only available on upstream)
# Those variables can be generated with: `nix-store --generate-binary-cache-key ci_nix_store priv.pem pub.pem`
.nix:
  <<: *upstream_only
  image: nixos/nix:2.32.1
  interruptible: true
  tags: [ fp ]

  before_script:
   - echo "experimental-features = nix-command flakes" >> /etc/nix/nix.conf
   - echo "substituters = file://$(pwd)/${NIX_STORE_ARTIFACTS_PATH} file://$(pwd)/${NIX_STORE_CACHE_PATH} https://cache.nixos.org" >> /etc/nix/nix.conf
   - echo "trusted-public-keys = ${NIX_CI_CACHE_PUB_KEY} cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=" >> /etc/nix/nix.conf

   # Since the cache is not guaranteed to be available, it is preferable to build the dependencies for each job (which is no-op if the cache is available)
   - nix build --print-build-logs ${DEPENDENCIES}

  variables:
    DEPENDENCIES: ".#theories.inputDerivation .#frontend.inputDerivation .#frontend.cargoArtifacts nixpkgs#gnumake nixpkgs#gnupatch nixpkgs#gnused"
    NIX_STORE_ARTIFACTS_PATH: ".ci_nix_artifacts"
    NIX_STORE_CACHE_PATH: ".ci_nix_cache"

  cache: &nix_cache
    key:
      files: [ flake.lock, flake.nix ]
    paths: [ "${NIX_STORE_CACHE_PATH}" ]
    policy: pull

.build_to_nix_cache:
  cache:
    <<: *nix_cache
    policy: pull-push

  script:
   - nix build --print-build-logs ${NIX_DERIVATION}
   - nix store sign --key-file <(echo "${NIX_CI_CACHE_PRIV_KEY}") --recursive ${NIX_DERIVATION}
   - nix copy --to "file://$(pwd)/${NIX_STORE_CACHE_PATH}" ${NIX_DERIVATION}

.build_to_nix_artifacts:
  artifacts:
    paths: [ "${NIX_STORE_ARTIFACTS_PATH}" ]
    when: always
    expire_in: 1 week

  script:
   - !reference [ .build_to_nix_cache, script ]

   # To avoid generating large `artifacts` without cluttering the `cache`, an overlay on top of the nix store must be used.
   # So, one of the following solutions can be used:
   #  1. Using OverlayFS (with `local-overlay` feature), but SYS_ADMIN capability is required
   #  2. Moving files around, which is not the best way to do
   - mkdir -p "${NIX_STORE_ARTIFACTS_PATH}/nar"
   - nix path-info ${NIX_DERIVATION} | xargs -r basename -a | cut -d'-' -f1 | xargs -r printf -- "${NIX_STORE_CACHE_PATH}/%s.narinfo\0" | xargs -r0 mv -v -t "${NIX_STORE_ARTIFACTS_PATH}" || true
   - find "${NIX_STORE_ARTIFACTS_PATH}" -name "*.narinfo" -type f -print0 | xargs -r0 grep -oPh "(?<=URL:\ ).*" | xargs -r printf -- "${NIX_STORE_CACHE_PATH}/%s\0" | xargs -r0 mv -v -t ${NIX_STORE_ARTIFACTS_PATH}/nar || true

nix-cache:
  extends: [ .nix, .build_to_nix_cache ]
  stage: nix-cache
  variables:
    NIX_DERIVATION: ${DEPENDENCIES}

clippy:
  extends: .nix
  stage: lint
  script:
   - cd rr_frontend
   - nix develop -c cargo clippy --all-targets --all-features --no-deps

fmt:
  extends: .nix
  stage: lint
  script:
   - cd rr_frontend
   - nix develop -c cargo fmt --check

deny:
  extends: .nix
  stage: lint
  script:
   - cd rr_frontend
   - nix develop -c cargo deny check

machete:
  extends: .nix
  stage: lint
  script:
   - cd rr_frontend
   - nix develop -c cargo machete

unused:
  extends: .nix
  stage: lint
  script:
   - cd rr_frontend
   - nix develop -c rust-analyzer scip . --output index.scip
   - nix develop -c cargo workspace-unused-pub --extensions rs,unused

theories:
  extends: [ .nix, .build_to_nix_artifacts ]
  stage: build
  needs: [ nix-cache ]
  variables:
    NIX_DERIVATION: .#theories

frontend:
  extends: [ .nix, .build_to_nix_artifacts ]
  stage: build
  needs: [ nix-cache ]
  variables:
    NIX_DERIVATION: .#frontend

stdlib:
  extends: [ .nix, .build_to_nix_artifacts ]
  stage: build
  needs: [ theories, frontend ]
  variables:
    NIX_DERIVATION: .#stdlib

frontend-tests:
  extends: .nix
  stage: tests
  needs: [ frontend ]
  script:
   - cd rr_frontend
   - nix develop -c cargo test

case_studies:
  extends: .nix
  stage: tests
  needs: [ stdlib ]
  script:
   - nix shell -c cargo refinedrust -V
   - nix shell -c nix run nixpkgs#gnumake -- generate_case_studies
   - cd case_studies
   - nix shell -c dune build --display=short


.opam:
  image: $CI_REGISTRY/gaeher/rust-ci
  interruptible: true
  stage: build
  needs: []

  variables:
    # dune takes care of parallelization itself and does not like running in parallel
    CPU_CORES: "1"
    # DENY_WARNINGS: "1"
    OCAML: "ocaml-variants.4.14.2+options ocaml-option-flambda"

  script:
   - git clone https://gitlab.mpi-sws.org/iris/ci.git ci -b opam2
   - make setup-dune-workspace
   - source "$HOME/.cargo/env"
   - ci/buildjob

  cache:
    key: "$CI_JOB_NAME"
    paths: [ "_opam/" ]

build-opam-rocq.9.1.0:
  <<: *forks_only
  extends: .opam
  tags: [ fp ]
  variables:
    OPAM_PINS: "rocq-core version 9.1.0 dune version 3.19.1"
    MAKE_TARGET: "all_with_examples"

build-opam-rocq.9.1.0-timing:
  <<: *upstream_only
  extends: .opam
  tags: [ fp-timing ]
  variables:
    OPAM_PINS: "rocq-core version 9.1.0 dune version 3.19.1"
    MAKE_TARGET: "all_with_examples"
