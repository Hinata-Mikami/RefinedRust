# Tutorial: Verifying a small example using RefinedRust

In this tutorial, we describe how to verify a small example using RefinedRust.
Concretely, we will be verifying a type representing even integers.

To start off, make sure that you have installed the RefinedRust frontend (i.e., that you can run `cargo refinedrust`).
If you used one of our setup scripts or `nix`, this is already the case.
Otherwise, you can perform the following steps in a checkout of this repository:
```
cd rr_frontend
./refinedrust build
./refinedrust install
```

Now, return back to the root of this repository. For simplicity, we are going to locate our new example inside this repository (although you can also locate it elsewhere in your filesystem).

## Getting started

The first step is to create a new Rust project using Cargo.
To that end, perform the following steps:
```
cd case_studies
cargo new evenint
```

This creates a new binary project in the folder `evenint`.
Change to this directory now with `cd evenint`.
You can verify with `cargo run` that the initial auto-generated code runs.

Now, we are going to add in our own code.
To that end, open the file `src/main.rs` in your favorite editor.
Currently, it should contain the following contents:
```
fn main() {
    println!("Hello, world!");
}
```

Let us replace this with the following initial code:

```
fn main() {
    let mut a;
    let b;
    unsafe {
        a = EvenInt::new(0);
        b = EvenInt::new(2);
    }

    a.add_even(&b);
    assert!(a.get() % 2 == 0);
}

struct EvenInt {
    num: i32,
}

impl EvenInt {
    /// Create a new even integer.
    pub unsafe fn new(x: i32) -> Self {
        Self {num: x}
    }

    /// Internal function. Unsafely add 1, making the integer odd.
    unsafe fn add(&mut self) {
        self.num += 1;
    }

    /// Get the even integer
    pub fn get(&self) -> i32 {
        self.num
    }

    /// Add another even integer.
    pub fn add_even(&mut self, other: &Self) {
        self.num += other.num;
    }

    /// Add 2 to an even integer.
    pub fn add_two(&mut self) {
        self.num;

        unsafe {
            self.add();
            self.add();
        }
    }
}
```

Our goal is to verify the assertion in the main function, i.e. that even integers indeed keep up the invariant that they are even.
To do so, we have to verify the interface that `EvenInt` provides by attaching RefinedRust specifications.

## Proving our first function

To get started, we have to tell Rust's compiler to expect RefinedRust annotations.
We can do so by putting the following lines at the top of the file:
```
#![feature(register_tool)]
#![register_tool(rr)]
#![feature(custom_inner_attributes)]
```

Now, the first step is to add an annotation to the struct declaration:
```
#[rr::refined_by("x" : "Z")]
#[rr::invariant("Zeven x")]
struct EvenInt {
    #[rr::field("x")]
    num: i32,
}
```
This invariant says that RefinedRust's mathematical model of `EvenInt` are Coq integers `Z` (using the `refined_by` clause).
The integer should be even, using Coq's `Zeven` predicate.
You can find a more thorough overview in the `SPEC_FORMAT.md` file placed in the same directory as this tutorial.

Using this specification for `EvenInt`, we can already give a sensible specification to the `new` function, mentioning the argument `x`:
```
#[rr::requires("Zeven x")]
#[rr::returns("x")]
```

We can run `cargo refinedrust` and `dune build` now, and after short time, the build process should succeed, telling us that the property was successfully verified.

## Inspecting the generated Coq code
Let us now inspect the Coq code that RefinedRust has generated.
By default, RefinedRust will place this code in a subdirectory of Cargo's `target` directory.
To make inspection easier in the sequel, we will configure RefinedRust to put the generated code in an `output` directory in the project directory.
To do so, we create a new file `RefinedRust.toml` in the project directory (alongside `Cargo.toml`) with the following contents:
```
output_dir="./output"
```
You can find more valid configuration options described in RefinedRust's readme.

Now, we can run `cargo clean && cargo refinedrust && dune build` to compile the Coq code in the new directory.

If you inspect the project directory now, you can find a new subdirectory `output` generated by RefinedRust.
Inside `output`, there should be a single directory `evenint` (named after the crate we are verifying), which in turn contains three elements:
* a folder `generated` with code generated by RefinedRust on each invocation of `cargo refinedrust`
* a folder `proofs` with one proof file for each function; these files are only generated on the first invocation and not overwritten on subsequent invocations
* a file `interface.rrlib` that enables RefinedRust to use this crate when verifying another crate using this one.

You can inspect the files `generated/generated_code_evenint.v` to see the Radium definitions RefinedRust generates,
as well as `generated/generated_specs_evenint.v` to see the RefinedRust type definitions generated.
Finally, the `proofs` directory should contain a proof file `proof_EvenInt_new.v` for `EvenInt::new`.

In order to run these files in your favorite Coq editor (e.g. Emacs with ProofGeneral), you need to
create a `_CoqProject` file in the root of the repository:
```
make case_studies/evenint.coqproject
```

## Verifying more functions
In the following, we will be verifying the functions `add_two` and `add`.

`add` is slightly interesting because it breaks `EvenInt`'s invariant, since it adds just `1`, making the even integer odd.
Only if called subsequently (as done by `add_two`) can it preserve the invariant.
This is why we have marked `add` as unsafe.

For `add` we take the following specification:
```
#[rr::params("x", "γ")]
#[rr::args(#raw "((-[x]), γ)")]
#[rr::requires("(x + 1 ≤ MaxInt i32)%Z")]
#[rr::observe("γ": "(-[#(x+1)%Z] : plistRT _)")]
```
The first noteworthy part is the `#raw` annotation on the first argument: it asserts that we do not require the invariant on `EvenInt` to currently hold.
That is why we also use `-[x]` for the contents of the mutable reference, which is the "raw" refinement for the struct (where `x` is the refinement of the first field) without the annotated invariant.
As we add 1, we require that `x + 1` fits into a `i32` integer.

For `add_two`, we add the following specification:
```
#[rr::requires("(x.cur + 2 ≤ MaxInt i32)%Z")]
#[rr::observe("x.ghost": "(x.cur + 2)")]
```
This works without the `#raw` annotation, as the function keeps the invariant intact.

### Manual proof hints
When checking `add_two`, you will find that RefinedRust will need some help.
Concretely, the proof will fail with an error message of the following shape:

```
Type system got stuck in function "EvenInt_add_two" !

Goal:
...

```

Here, the type system could not make progress anymore.
A closer inspection of the message reveals the proof goal the type system got stuck at:
```
typed_val_expr [ϝ ⊑ₑ ulft_1; ϝ ⊑ₑ ulft_1] [κ ⊑ₗ{ 0} [ulft_1]; ϝ ⊑ₗ{ 1} []]
  (&ref{Mut,Some (RSTLitType ["EvenInt_inv_t"] (RSTScopeInst [] [] [])),"llft3"} (!{PtrOp}arg_self))%E
...
```
This means that the type system got stuck when checking the expression
`&ref{Mut,Some (RSTLitType ["EvenInt_inv_t"] (RSTScopeInst [] [] [])),"llft3"} (!{PtrOp}arg_self)`,
i.e., it attempted to do a mutable borrow of the dereferenced argument `self` at type `EvenInt_inv_t` (the type that `EvenInt` has when its invariant is upheld).
Presumably, this is the implicit reborrow that Rust does when calling `self.add()`.
At this point, let us step into the Rocq proof and interactively investigate this.

For that, open the proof file for `EvenInt::add_two`, which should be located at `output/minivec/proofs/proof_EvenInt_add_two.v`.
Currently, it contains mainly a proof of the following shape:
```
Lemma EvenInt_add_two_proof (π : thread_id) :
  EvenInt_add_two_lemma π.
Proof.
  EvenInt_add_two_prelude.

  rep <-! liRStep; liShow.

  all: print_remaining_goal.
  Unshelve. all: sidecond_solver.
  Unshelve. all: sidecond_hammer.
  Unshelve. all: print_remaining_sidecond.
Qed.
```
This proof will not be overwritten by RefinedRust on subsequent invocations, so we can safely change it.
It consists of the following components:
- `EvenInt_add_two_prelude.` is a function-specific tactic that RefinedRust generated to prepare the proof context.
- `repeat liRStep; liShow.` invokes RefinedRust's type system. After running this, a few shelved pure sideconditions remain.
- the rest of the proof calls into RefinedRust's sidecondition solvers for pure Rocq sideconditions.

Currently, `rep <-! liRStep; liShow.` will not fully solve the type-checking obligations; it will stop at the last so-called backtracking point before it fails -- in this case, the mutable re-borrow.
We can tell RefinedRust to progress type-checking until the failure point, by adding `rep liRStep; liShow.` .
This advances the typesystem state to a goal of this form:
```
weak_subtype [ϝ ⊑ₑ ulft_1; ϝ ⊑ₑ ulft_1] [κ ⊑ₗ{ 0} [ulft_1]; ϝ ⊑ₗ{ 1} []]
  -[# self] (protected Hevar)
  (struct_t EvenInt_sls +[int i32]) (∃; EvenInt_inv_t_inv_spec <INST!>, (EvenInt_ty <INST!>))
```
This means that RefinedRust is proving a subtyping relation of the form `struct_t EvenInt_sls +[int i32] ⊆ (∃; EvenInt_inv_t_inv_spec <INST!>, (EvenInt_ty <INST!>))`,
i.e., it is trying to establish the invariant for `EvenInt` (when performing the borrow).

In this case, however, we do not want to establish the invariant at all: `self.add()`'s specification does not require the invariant to be established.
Thus, we can modify the proof to the following:
```
rep <-! liRStep; liShow.
liRStepUntil interpret_typing_hint.
iApply interpret_typing_hint_ignore.
```
First, `liRStepUntil` steps until the typing state reaches the given judgment `interpret_typing_hint`, which is responsible for interpreting the typing hint for the borrow and establishing it.
Then, we apply a typing rule for ignoring the typing hint.

Now we can make progress!
Calling `rep liRStep; liShow.` again will lead us to the same error for the second call to `self.add()`.
We can apply the same trick again, resulting in the full proof script:

```
rep <-! liRStep; liShow.
liRStepUntil interpret_typing_hint.
iApply interpret_typing_hint_ignore.
rep <-! liRStep; liShow.
liRStepUntil interpret_typing_hint.
iApply interpret_typing_hint_ignore.
rep <-! liRStep; liShow.
```

This should conclude the main type-checking procedure of RefinedRust, and no goals should remain.
What is now left is to prove the *sideconditions* that the type-checking procedure emitted, residing on Rocq's shelf.

If you run the remaining lines
```

  all: print_remaining_goal.
  Unshelve. all: sidecond_solver.
  Unshelve. all: sidecond_hammer.
  Unshelve. all: print_remaining_sidecond.
```
most of these sideconditions will be dispatched automatically, but you will receive the following message:
```
Shelved goal remaining in  "EvenInt_add_two" !
Goal:
....
---------
(Inhabited (Zeven (x + 1 + 1)))
```
This message says that RefinedRust's solvers were not able to prove that `x + 1 + 1` is even again!
At this point we have to step in manually.

In this case, after `sidecond_hammer`, the sidecondition `Zeven (x + 1 + 1)` is still remaining.
Luckily, we know that `Zeven x`, so we can add the following line to solve it:
```
{ rewrite -Z.add_assoc; apply Zeven_plus_Zeven; solve_goal. }
```
The final proof script should look like this:
```
Lemma EvenInt_add_two_proof (π : thread_id) :
  EvenInt_add_two_lemma π.
Proof.
  EvenInt_add_two_prelude.

  rep <-! liRStep; liShow.
  liRStepUntil interpret_typing_hint.
  iApply interpret_typing_hint_ignore.
  rep <-! liRStep; liShow.
  liRStepUntil interpret_typing_hint.
  iApply interpret_typing_hint_ignore.
  rep <-! liRStep; liShow.

  all: print_remaining_goal.
  Unshelve. all: sidecond_solver.
  Unshelve. all: sidecond_hammer.
  { rewrite -Z.add_assoc; apply Zeven_plus_Zeven; solve_goal. }
  Unshelve. all: print_remaining_sidecond.
Qed.
```

## Your turn!
We leave it as an exercise to the reader to verify the function `add_even`.

