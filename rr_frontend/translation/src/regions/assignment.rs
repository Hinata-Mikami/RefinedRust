// © 2024, The RefinedRust Developers and Contributors
//
// This Source Code Form is subject to the terms of the BSD-3-clause License.
// If a copy of the BSD-3-clause license was not distributed with this
// file, You can obtain one at https://opensource.org/license/bsd-3-clause/.

//! Provides functionality for generating lifetime annotations for assignments.

use std::collections::{BTreeMap, HashMap, HashSet};

use derive_more::{Constructor, Debug};
use log::{info, warn};
use rr_rustc_interface::hir::def_id::DefId;
use rr_rustc_interface::middle::mir::tcx::PlaceTy;
use rr_rustc_interface::middle::mir::{BasicBlock, BorrowKind, Location, Rvalue};
use rr_rustc_interface::middle::ty;
use rr_rustc_interface::middle::ty::{Ty, TyCtxt, TyKind, TypeFoldable};
use ty::TypeSuperFoldable;

use crate::base::{self, Region};
use crate::environment::borrowck::facts;
use crate::environment::polonius_info::PoloniusInfo;
use crate::environment::{dump_borrowck_info, polonius_info, Environment};
use crate::regions::arg_folder::ty_instantiate;
use crate::regions::inclusion_tracker::{self, InclusionTracker};
use crate::regions::EarlyLateRegionMap;
use crate::{regions, types};

/// Generate inclusions for a strong update assignment.
fn get_assignment_strong_update_constraints(
    inclusion_tracker: &InclusionTracker<'_, '_>,
    loc: Location,
) -> HashSet<(Region, Region, base::PointIndex)> {
    let info = inclusion_tracker.info();
    let input_facts = &info.borrowck_in_facts;
    let subset_base = &input_facts.subset_base;

    let mut constraints = HashSet::new();
    // Polonius subset constraint are spawned for the midpoint
    let midpoint = info.interner.get_point_index(&facts::Point {
        location: loc,
        typ: facts::PointType::Mid,
    });

    // for strong update: emit mutual equalities
    // TODO: alternative implementation: structurally compare regions in LHS type and RHS type
    for (s1, s2, point) in subset_base {
        if *point == midpoint {
            let lft1 = info.mk_atomic_region(*s1);
            let lft2 = info.mk_atomic_region(*s2);

            // We only care about inclusions into a place lifetime.
            // Moreover, we want to filter out the universal inclusions which are always
            // replicated at every point.
            if lft2.is_place() && !lft1.is_universal() {
                // take this constraint and the reverse constraint
                constraints.insert((*s1, *s2, *point));
                //constraints.insert((*s2, *s1, *point));
            }
        }
    }
    constraints
}

/// Generate inclusions for a weak update assignment.
fn get_assignment_weak_update_constraints(
    inclusion_tracker: &mut InclusionTracker<'_, '_>,
    loc: Location,
) -> HashSet<(Region, Region, base::PointIndex)> {
    let info = inclusion_tracker.info();
    let input_facts = &info.borrowck_in_facts;
    let subset_base = &input_facts.subset_base;

    let mut constraints = HashSet::new();
    // Polonius subset constraint are spawned for the midpoint
    let midpoint = info.interner.get_point_index(&facts::Point {
        location: loc,
        typ: facts::PointType::Mid,
    });

    // for weak updates: should mirror the constraints generated by Polonius
    for (s1, s2, point) in subset_base {
        if *point == midpoint {
            // take this constraint
            // TODO should there be exceptions to this?

            if !inclusion_tracker.check_inclusion(*s1, *s2, *point) {
                // only add it if it does not hold already, since we will enforce this
                // constraint dynamically.
                constraints.insert((*s1, *s2, *point));
            }
        }
    }
    constraints
}

/// Get all region variables mentioned in a place type.
fn find_region_variables_of_place_type<'tcx>(env: &Environment<'tcx>, ty: PlaceTy<'tcx>) -> HashSet<Region> {
    let mut collector = regions::TyRegionCollectFolder::new(env.tcx());
    if ty.variant_index.is_some() {
        panic!("find_region_variables_of_place_type: don't support enums");
    }

    ty.ty.fold_with(&mut collector);
    collector.get_regions()
}

/// Compute the annotations for an assignment: an annotation for the rhs value, and a list of
/// annotations to prepend to the statement, and a list of annotations to put after the
/// statement.
pub fn get_assignment_annots<'tcx>(
    env: &Environment<'tcx>,
    inclusion_tracker: &mut InclusionTracker<'_, 'tcx>,
    ty_translator: &types::LocalTX<'_, 'tcx>,
    loc: Location,
    lhs_strongly_writeable: bool,
    lhs_ty: PlaceTy<'tcx>,
    _rhs_ty: Ty<'tcx>,
) -> (Option<radium::Annotation>, Vec<radium::Annotation>, Vec<radium::Annotation>) {
    let info = inclusion_tracker.info();
    let new_dyn_inclusions;
    let expr_annot;
    let stmt_annot;
    if lhs_strongly_writeable {
        // we are going to update the region mapping through annotations,
        // and hence put up a barrier for propagation of region constraints

        // structurally go over the type and find region variables.
        // for each of the variables, issue a barrier.
        // also track them together with the PlaceItems needed to reach them.
        // from the latter, we can generate the necessary annotations
        let regions = find_region_variables_of_place_type(env, lhs_ty);

        // put up a barrier at the Mid point
        let barrier_point_index = info.interner.get_point_index(&facts::Point {
            location: loc,
            typ: facts::PointType::Mid,
        });
        for r in &regions {
            inclusion_tracker.add_barrier(*r, barrier_point_index);
        }
        // get new constraints that should be enforced
        let new_constraints = get_assignment_strong_update_constraints(inclusion_tracker, loc);
        stmt_annot = Vec::new();
        for (r1, r2, p) in &new_constraints {
            inclusion_tracker.add_static_inclusion(*r1, *r2, *p);
            inclusion_tracker.add_static_inclusion(*r2, *r1, *p);

            // TODO: use this instead of the expr_annot below
            //stmt_annot.push(
            //radium::Annotation::CopyLftName(
            //self.format_region(*r1),
            //self.format_region(*r2),
            //));
        }

        // TODO: get rid of this
        // similarly generate an annotation that encodes these constraints in the RR
        // type system
        expr_annot = generate_strong_update_annot(ty_translator, info, lhs_ty);
        //expr_annot = None;

        new_dyn_inclusions = HashSet::new();
    } else {
        // need to filter out the constraints that are relevant here.
        // incrementally go through them.
        new_dyn_inclusions = get_assignment_weak_update_constraints(inclusion_tracker, loc);
        expr_annot = None;
        stmt_annot = Vec::new();
    }

    // First enforce the new inclusions, then do the other annotations
    let new_dyn_inclusions =
        generate_dyn_inclusion_annots(inclusion_tracker, ty_translator, &new_dyn_inclusions);
    (expr_annot, new_dyn_inclusions, stmt_annot)
}

/// Generates dynamic inclusions for the set of inclusions in `incls`.
/// These inclusions should not hold yet.
/// Skips mutual inclusions -- we cannot interpret these.
fn generate_dyn_inclusion_annots<'tcx>(
    inclusion_tracker: &mut InclusionTracker<'_, 'tcx>,
    ty_translator: &types::LocalTX<'_, 'tcx>,
    incls: &HashSet<(Region, Region, base::PointIndex)>,
) -> Vec<radium::Annotation> {
    // before executing the assignment, first enforce dynamic inclusions
    info!("Generating dynamic inclusions {:?}", incls);

    let inclusions = inclusion_tracker.generate_dyn_inclusions(incls);

    inclusions
        .into_iter()
        .map(|incl| match incl {
            inclusion_tracker::DynamicInclusion::ExtendLft(l) => {
                radium::Annotation::ExtendLft(ty_translator.format_atomic_region(&l))
            },
            inclusion_tracker::DynamicInclusion::IncludeLft(l1, l2) => radium::Annotation::DynIncludeLft(
                ty_translator.format_atomic_region(&l1),
                ty_translator.format_atomic_region(&l2),
            ),
        })
        .collect()
}

/// Generate an annotation on an expression needed to update the region name map.
fn generate_strong_update_annot<'tcx>(
    ty_translator: &types::LocalTX<'_, 'tcx>,
    info: &PoloniusInfo<'_, 'tcx>,
    ty: PlaceTy<'tcx>,
) -> Option<radium::Annotation> {
    let (interesting, tree) = generate_strong_update_annot_rec(ty_translator, info, ty.ty);
    interesting.then(|| radium::Annotation::GetLftNames(tree))
}

/// Returns a tree for giving names to Coq lifetimes based on RR types.
/// The boolean indicates whether the tree is "interesting", i.e. whether it names at least one
/// lifetime.
fn generate_strong_update_annot_rec<'tcx>(
    ty_translator: &types::LocalTX<'_, 'tcx>,
    info: &PoloniusInfo<'_, 'tcx>,
    ty: Ty<'tcx>,
) -> (bool, radium::LftNameTree) {
    // TODO for now this just handles nested references
    match ty.kind() {
        ty::TyKind::Ref(r, ty, _) => match r.kind() {
            ty::RegionKind::ReVar(r) => {
                let name = ty_translator.format_atomic_region(&info.mk_atomic_region(r));
                let (_, ty_tree) = generate_strong_update_annot_rec(ty_translator, info, *ty);
                (true, radium::LftNameTree::Ref(name, Box::new(ty_tree)))
            },
            _ => {
                panic!("generate_strong_update_annot: expected region variable");
            },
        },
        _ => (false, radium::LftNameTree::Leaf),
    }
}

/// Generate an annotation to adapt the type of `expr` to `target_ty` from type `current_ty` by
/// means of shortening lifetimes.
fn generate_shortenlft_annot<'tcx>(
    ty_translator: &types::LocalTX<'_, 'tcx>,
    info: &PoloniusInfo<'_, 'tcx>,
    target_ty: Ty<'tcx>,
    _current_ty: Ty<'tcx>,
    mut expr: radium::Expr,
) -> radium::Expr {
    // this is not so different from the strong update annotation
    let (interesting, tree) = generate_strong_update_annot_rec(ty_translator, info, target_ty);
    if interesting {
        expr = radium::Expr::Annot {
            a: radium::Annotation::ShortenLft(tree),
            e: Box::new(expr),
            why: None,
        };
    }
    expr
}

/// Find all regions that need to outlive a loan region at its point of creation, and
/// add the corresponding constraints to the inclusion tracker.
fn get_outliving_regions_on_loan(
    inclusion_tracker: &mut InclusionTracker<'_, '_>,
    r: Region,
    loan_point: base::PointIndex,
) -> Vec<Region> {
    // get all base subset constraints r' ⊆ r
    let info = inclusion_tracker.info();
    let input_facts = &info.borrowck_in_facts;
    let mut outliving = Vec::new();

    let subset_base = &input_facts.subset_base;
    for (r1, r2, p) in subset_base {
        if *p == loan_point && *r2 == r {
            inclusion_tracker.add_static_inclusion(*r1, *r2, *p);
            outliving.push(*r1);
        }
        // other subset constraints at this point are due to (for instance) the assignment of
        // the loan to a place and are handled there.
    }
    outliving
}

/// Get the annotations due to borrows appearing on the RHS of an assignment.
pub fn get_assignment_loan_annots<'tcx>(
    inclusion_tracker: &mut InclusionTracker<'_, 'tcx>,
    ty_translator: &types::LocalTX<'_, 'tcx>,
    loc: Location,
    rhs: &Rvalue<'tcx>,
) -> Vec<radium::Annotation> {
    let info = inclusion_tracker.info();
    let mut stmt_annots = Vec::new();

    // if we create a new loan here, start a new lifetime for it
    let loan_point = info.get_point(loc, facts::PointType::Mid);
    if let Some(loan) = info.get_optional_loan_at_location(loc) {
        // TODO: is this fine for aggregates? I suppose, if I create a loan for an
        // aggregate, I want to use the same atomic region for all of its components
        // anyways.

        let lft = info.atomic_region_of_loan(loan);
        let r = lft.get_region();

        // get the static inclusions we need to generate here and add them to the
        // inclusion tracker
        let outliving = get_outliving_regions_on_loan(inclusion_tracker, r, loan_point);

        // add statement for issuing the loan
        stmt_annots.insert(
            0,
            radium::Annotation::StartLft(
                ty_translator.format_atomic_region(&lft),
                outliving
                    .iter()
                    .map(|r| ty_translator.format_atomic_region(&info.mk_atomic_region(*r)))
                    .collect(),
            ),
        );

        let a = info.get_region_kind(r);
        info!("Issuing loan at {:?} with kind {:?}: {:?}; outliving: {:?}", loc, a, loan, outliving);
    } else if let Rvalue::Ref(region, BorrowKind::Shared, _) = rhs {
        // for shared reborrows, Polonius does not create a new loan, and so the
        // previous case did not match.
        // However, we still need to track the region created for the reborrow in an
        // annotation.

        let region = regions::region_to_region_vid(*region);

        // find inclusion ?r1 ⊑ region -- we will actually enforce region = r1
        let new_constrs: Vec<(facts::Region, facts::Region)> =
            info.get_new_subset_constraints_at_point(loan_point);
        info!("Shared reborrow at {:?} with new constrs: {:?}", region, new_constrs);
        let mut included_region = None;
        for (r1, r2) in &new_constrs {
            if *r2 == region {
                included_region = Some(r1);
                break;
            }
        }
        if let Some(r) = included_region {
            //info!("Found inclusion {:?}⊑  {:?}", r, region);
            stmt_annots.push(radium::Annotation::CopyLftName(
                ty_translator.format_atomic_region(&info.mk_atomic_region(*r)),
                ty_translator.format_atomic_region(&info.mk_atomic_region(region)),
            ));

            // also add this to the inclusion checker
            inclusion_tracker.add_static_inclusion(*r, region, loan_point);
        } else {
            // This happens e.g. when borrowing from a raw pointer etc.
            info!("Found unconstrained shared borrow for {:?}", region);
            let inferred_constrained = vec![];

            // add statement for issuing the loan
            stmt_annots.push(radium::Annotation::StartLft(
                ty_translator.format_atomic_region(&info.mk_atomic_region(region)),
                inferred_constrained,
            ));
        }
    }

    stmt_annots
}
