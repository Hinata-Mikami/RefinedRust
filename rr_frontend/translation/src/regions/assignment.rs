// © 2024, The RefinedRust Developers and Contributors
//
// This Source Code Form is subject to the terms of the BSD-3-clause License.
// If a copy of the BSD-3-clause license was not distributed with this
// file, You can obtain one at https://opensource.org/license/bsd-3-clause/.

//! Provides functionality for generating lifetime annotations for assignments.

use std::collections::BTreeSet;

use log::{info, trace, warn};
use radium::{code, coq, specs};
use rr_rustc_interface::middle::ty::TypeFoldable as _;
use rr_rustc_interface::middle::{mir, ty};

use crate::base::*;
use crate::environment::Environment;
use crate::environment::borrowck::facts;
use crate::regions::inclusion_tracker::{self, InclusionTracker};
use crate::{regions, types};

/// Generate inclusions for a strong update assignment.
fn get_assignment_strong_update_constraints(
    inclusion_tracker: &mut InclusionTracker<'_, '_>,
    loc: mir::Location,
) -> BTreeSet<(Region, Region, PointIndex)> {
    let info = inclusion_tracker.info();
    let input_facts = &info.borrowck_in_facts;
    let subset_base = &input_facts.subset_base;

    let mut constraints = BTreeSet::new();
    // Polonius subset constraint are spawned for the midpoint
    let midpoint = info.interner.get_point_index(&facts::Point {
        location: loc,
        typ: facts::PointType::Mid,
    });

    // for strong update: emit mutual equalities
    // TODO: alternative implementation: structurally compare regions in LHS type and RHS type
    for (s1, s2, point) in subset_base {
        if *point == midpoint {
            let lft2 = info.mk_atomic_region(*s2);

            if inclusion_tracker.check_inclusion(*s1, *s2, *point) {
                continue;
            }

            // We only care about inclusions into a place lifetime.
            // Moreover, we want to filter out the universal inclusions which are always
            // replicated at every point.
            // TODO sometimes we need the univ constraint.
            if lft2.is_place() {
                //&& !lft1.is_universal()
                constraints.insert((*s1, *s2, *point));
            }
            //else if lft1.is_universal() && lft2.is_value() && subset_base.contains
        }
    }
    constraints
}

/// Generate inclusions for a weak update assignment.
fn get_assignment_weak_update_constraints(
    inclusion_tracker: &mut InclusionTracker<'_, '_>,
    loc: mir::Location,
) -> BTreeSet<(Region, Region, PointIndex)> {
    let info = inclusion_tracker.info();
    let input_facts = &info.borrowck_in_facts;
    let subset_base = &input_facts.subset_base;

    let mut constraints = BTreeSet::new();
    // Polonius subset constraint are spawned for the midpoint
    let midpoint = info.interner.get_point_index(&facts::Point {
        location: loc,
        typ: facts::PointType::Mid,
    });

    // for weak updates: should mirror the constraints generated by Polonius
    for (s1, s2, point) in subset_base {
        if *point == midpoint {
            // take this constraint
            // TODO should there be exceptions to this?
            // let lft1 = info.mk_atomic_region(*s1);
            // let lft2 = info.mk_atomic_region(*s2);

            //if lft2.is_place() && !lft1.is_universal() {
            if !inclusion_tracker.check_inclusion(*s1, *s2, *point) {
                // only add it if it does not hold already, since we will enforce this
                // constraint dynamically.
                constraints.insert((*s1, *s2, *point));
            }
            //}
        }
    }
    constraints
}

/// Get all region variables mentioned in a place type.
fn find_region_variables_of_place_type<'tcx>(
    env: &Environment<'tcx>,
    ty: mir::PlaceTy<'tcx>,
) -> BTreeSet<Region> {
    let mut collector = regions::TyRegionCollectFolder::new(env.tcx());
    if ty.variant_index.is_some() {
        panic!("find_region_variables_of_place_type: don't support enums");
    }

    ty.ty.fold_with(&mut collector);
    collector.get_regions()
}

/// Get newly introduced regions at this point which are unconstrained.
fn get_new_unconstrained_regions(
    inclusion_tracker: &InclusionTracker<'_, '_>,
    loc: mir::Location,
) -> BTreeSet<Region> {
    let info = inclusion_tracker.info();
    let input_facts = &info.borrowck_in_facts;
    let subset_base = &input_facts.subset_base;

    // Polonius subset constraint are spawned for the midpoint
    let midpoint = info.interner.get_point_index(&facts::Point {
        location: loc,
        typ: facts::PointType::Mid,
    });

    let mut unconstrained_regions = BTreeSet::new();

    // for weak updates: should mirror the constraints generated by Polonius
    for (s1, _, point) in subset_base {
        if *point == midpoint {
            // take this constraint
            // TODO should there be exceptions to this?
            let lft1 = info.mk_atomic_region(*s1);

            if lft1.is_unconstrained() {
                unconstrained_regions.insert(*s1);
            }
        }
    }
    unconstrained_regions
}

#[derive(Debug)]
pub(crate) struct RegionInfo {
    pub expr_annot: Option<code::Annotation>,
    pub new_dyn_inclusions: Vec<code::Annotation>,
    pub stmt_annot: Vec<code::Annotation>,
    pub unconstrained_regions: BTreeSet<Region>,
}

/// Compute the annotations for an assignment: an annotation for the rhs value, and a list of
/// annotations to prepend to the statement, and a list of annotations to put after the
/// statement.
pub(crate) fn get_assignment_annots<'tcx>(
    env: &Environment<'tcx>,
    inclusion_tracker: &mut InclusionTracker<'_, 'tcx>,
    ty_translator: &types::LocalTX<'_, 'tcx>,
    loc: mir::Location,
    lhs_strongly_writeable: bool,
    lhs_ty: mir::PlaceTy<'tcx>,
    _rhs_ty: ty::Ty<'tcx>,
) -> RegionInfo {
    let info = inclusion_tracker.info();
    let new_dyn_inclusions;
    let expr_annot;
    let mut stmt_annot = Vec::new();

    let unconstrained_regions = get_new_unconstrained_regions(inclusion_tracker, loc);

    if lhs_strongly_writeable {
        // we are going to update the region mapping through annotations,
        // and hence put up a barrier for propagation of region constraints

        // structurally go over the type and find region variables.
        // for each of the variables, issue a barrier.
        // also track them together with the PlaceItems needed to reach them.
        // from the latter, we can generate the necessary annotations
        let regions = find_region_variables_of_place_type(env, lhs_ty);

        // put up a barrier at the Mid point
        let pre_barrier_point_index = info.interner.get_point_index(&facts::Point {
            location: loc,
            typ: facts::PointType::Start,
        });
        let barrier_point_index = info.interner.get_point_index(&facts::Point {
            location: loc,
            typ: facts::PointType::Mid,
        });
        trace!("strong update barriers: {regions:?}");
        for r in &regions {
            inclusion_tracker.add_barrier(*r, barrier_point_index);
        }
        // get new constraints that should be enforced
        let new_constraints = get_assignment_strong_update_constraints(inclusion_tracker, loc);
        trace!("new strong update constraints: {new_constraints:?}");
        for (r1, r2, p) in &new_constraints {
            let ar1 = inclusion_tracker.info().mk_atomic_region(*r1);
            let ar2 = inclusion_tracker.info().mk_atomic_region(*r2);

            // Don't make an assignment if the region we are copying is not known.
            // This does not hold true for loans or unconstrained regions, which are being made
            // known not by constraints but by introduction.
            if !inclusion_tracker.is_region_known(*r1, pre_barrier_point_index)
                && !ar1.is_loan()
                && !ar1.is_unconstrained()
            {
                continue;
            }
            inclusion_tracker.add_static_inclusion(*r1, *r2, *p);
            inclusion_tracker.add_static_inclusion(*r2, *r1, *p);

            stmt_annot.push(code::Annotation::CopyLftName(
                ty_translator.format_atomic_region(ar1),
                ty_translator.format_atomic_region(ar2),
            ));
        }

        expr_annot = None;

        new_dyn_inclusions = BTreeSet::new();
    } else {
        // need to filter out the constraints that are relevant here.
        // incrementally go through them.
        new_dyn_inclusions = get_assignment_weak_update_constraints(inclusion_tracker, loc);
        expr_annot = None;
    }

    // First enforce the new inclusions, then do the other annotations
    let new_dyn_inclusions =
        generate_dyn_inclusion_annots(inclusion_tracker, ty_translator, &new_dyn_inclusions);

    RegionInfo {
        expr_annot,
        new_dyn_inclusions,
        stmt_annot,
        unconstrained_regions,
    }
}

/// Generates dynamic inclusions for the set of inclusions in `incls`.
/// These inclusions should not hold yet.
/// Skips mutual inclusions -- we cannot interpret these.
fn generate_dyn_inclusion_annots<'tcx>(
    inclusion_tracker: &mut InclusionTracker<'_, 'tcx>,
    ty_translator: &types::LocalTX<'_, 'tcx>,
    incls: &BTreeSet<(Region, Region, PointIndex)>,
) -> Vec<code::Annotation> {
    // before executing the assignment, first enforce dynamic inclusions
    info!("Generating dynamic inclusions {:?}", incls);

    let inclusions = inclusion_tracker.generate_dyn_inclusions(incls);

    inclusions
        .into_iter()
        .map(|incl| match incl {
            inclusion_tracker::DynamicInclusion::ExtendLft(l) => {
                code::Annotation::ExtendLft(ty_translator.format_atomic_region(l))
            },
            inclusion_tracker::DynamicInclusion::IncludeLft(l1, l2) => code::Annotation::DynIncludeLft(
                ty_translator.format_atomic_region(l1),
                ty_translator.format_atomic_region(l2),
            ),
        })
        .collect()
}

/// Find all regions that need to outlive a loan region at its point of creation, and
/// add the corresponding constraints to the inclusion tracker.
fn get_outliving_regions_on_loan(
    inclusion_tracker: &mut InclusionTracker<'_, '_>,
    r: Region,
    loan_point: PointIndex,
) -> Vec<Region> {
    // get all base subset constraints r' ⊆ r
    let info = inclusion_tracker.info();
    let input_facts = &info.borrowck_in_facts;
    let mut outliving = Vec::new();

    let subset_base = &input_facts.subset_base;
    for (r1, r2, p) in subset_base {
        if *p == loan_point && *r2 == r {
            inclusion_tracker.add_static_inclusion(*r1, *r2, *p);
            outliving.push(*r1);
        }
        // other subset constraints at this point are due to (for instance) the assignment of
        // the loan to a place and are handled there.
    }
    outliving
}

/// Get the annotations due to borrows appearing on the RHS of an assignment.
pub(crate) fn get_assignment_loan_annots<'tcx>(
    inclusion_tracker: &mut InclusionTracker<'_, 'tcx>,
    ty_translator: &types::LocalTX<'_, 'tcx>,
    loc: mir::Location,
    _rhs: &mir::Rvalue<'tcx>,
) -> Vec<code::Annotation> {
    let info = inclusion_tracker.info();
    let mut stmt_annots = Vec::new();

    // if we create a new loan here, start a new lifetime for it
    let loan_point = info.get_point(loc, facts::PointType::Mid);
    if let Some(loan) = info.get_optional_loan_at_location(loc) {
        // TODO: is this fine for aggregates? I suppose, if I create a loan for an
        // aggregate, I want to use the same atomic region for all of its components
        // anyways.

        let lft = info.atomic_region_of_loan(loan);
        let r = lft.get_region();

        // get the static inclusions we need to generate here and add them to the
        // inclusion tracker
        let outliving = get_outliving_regions_on_loan(inclusion_tracker, r, loan_point);

        let mut outliving_lfts: Vec<_> = outliving
            .iter()
            .map(|r| ty_translator.format_atomic_region(info.mk_atomic_region(*r)))
            .collect();
        // If there are no constraints, at least constrain the lifetime by the lifetime of the
        // current function
        if outliving_lfts.is_empty() {
            outliving_lfts.push(coq::Ident::new("_flft"));
        }

        // add statement for issuing the loan
        stmt_annots
            .insert(0, code::Annotation::StartLft(ty_translator.format_atomic_region(lft), outliving_lfts));

        let a = info.get_region_kind(r);
        info!("Issuing loan at {:?} with kind {:?}: {:?}; outliving: {:?}", loc, a, loan, outliving);
    }

    stmt_annots
}

/// Make annotations for unconstrained regions introduced by the current assignment.
pub(crate) fn make_unconstrained_region_annotations<'tcx>(
    inclusion_tracker: &mut InclusionTracker<'_, 'tcx>,
    ty_translator: &types::LocalTX<'_, 'tcx>,
    unconstrained_regions: BTreeSet<Region>,
    loc: mir::Location,
    rhs: Option<&mir::Rvalue<'tcx>>,
) -> Result<(Vec<code::Annotation>, Vec<specs::Lft>), TranslationError<'tcx>> {
    let mut annotations = Vec::new();

    let info = inclusion_tracker.info();
    let loan_point = info.get_point(loc, facts::PointType::Mid);

    let mut unconstrained_hints = Vec::new();
    for r in unconstrained_regions {
        if let Some(rhs) = rhs {
            if let mir::Rvalue::Ref(region, mir::BorrowKind::Shared, _) = rhs {
                // for shared reborrows, Polonius does not create a new loan, and so the
                // previous case did not match.
                // However, we still need to track the region created for the reborrow in an
                // annotation.

                let region = regions::region_to_region_vid(*region);

                // find inclusion ?r1 ⊑ region -- we will actually enforce region = r1
                let new_constrs: Vec<(facts::Region, facts::Region)> =
                    info.get_new_subset_constraints_at_point(loan_point);
                info!("Shared reborrow at {:?} with new constrs: {:?}", region, new_constrs);
                let mut included_region = None;
                for (r1, r2) in &new_constrs {
                    if *r2 == region {
                        included_region = Some(r1);
                        break;
                    }
                }
                if let Some(r) = included_region {
                    //info!("Found inclusion {:?}⊑  {:?}", r, region);
                    annotations.push(code::Annotation::CopyLftName(
                        ty_translator.format_atomic_region(info.mk_atomic_region(*r)),
                        ty_translator.format_atomic_region(info.mk_atomic_region(region)),
                    ));

                    // also add this to the inclusion checker
                    inclusion_tracker.add_static_inclusion(*r, region, loan_point);
                    continue;
                }
            }

            // Detect uses of static variables
            if let mir::Rvalue::Use(mir::Operand::Constant(_)) = rhs {
                // we are probably using a static variable here
                let lft = ty_translator.translate_region_var(r)?;
                annotations.push(code::Annotation::CopyLftName(coq::Ident::new("static"), lft));
                continue;
            }

            // If we do a borrow, probably this is a borrow from below a raw pointer.
            // In this case, ask the user to provide the constraints for this borrow.
            if let mir::Rvalue::Ref(region, _, _) = rhs
                && region.as_var() == r.into()
            {
                let lft = ty_translator.translate_region_var(r)?;
                annotations.push(code::Annotation::UnconstrainedLft(lft.clone()));
                unconstrained_hints.push(lft);
                continue;
            }

            // other cases?
            warn!("Encountered unconstrained region {r:?}, proof will likely fail");

            // in case we initialize enums where the lifetime is unconstrained (e.g. `None` in `Option<&T>`)
            let lft = ty_translator.translate_region_var(r)?;
            annotations.push(code::Annotation::CopyLftName(coq::Ident::new("static"), lft));
        }
    }

    Ok((annotations, unconstrained_hints))
}
