From refinedrust Require Import type generics existentials.
From iris.proofmode Require Import coq_tactics reduction string_ident.

(** ** Automation for solving obligations generated by defining existential types for sharing etc.*)

Ltac intro_adt_params :=
  repeat match goal with
         | |- ∀ _ : prod_vec lft _, _ => intros _
         | |- ∀ _ : plist type _, _ => intros _
         | |- ∀ _ : nil_unit, _ => intros _
         | |- ∀ _ : lft, _ => intros ?
         | |- ∀ _ : type _, _ => intros ?
         | |- ∀ _ : cons_prod _ _, _ => intros _
  end.

(** Currently tailored specifically to our needs.
   TODO In future, it might be more robust to instantiate Diaframe for this. *)
(* Recursively destruct a product in hypothesis H, using the given name as template. *)
Ltac destruct_product_hypothesis name H :=
  match goal with
  | H : (_ * _)%type |- _ => let tmp1 := fresh name in
                      let tmp2 := fresh name in
                      destruct H as [tmp1 tmp2];
                      destruct_product_hypothesis name tmp1;
                      destruct_product_hypothesis name tmp2
  |           |- _ => idtac
  end.

Local Ltac prepare_initial_coq_context :=
  (* The automation assumes that all products in the context are destructed, see liForall *)
  repeat lazymatch goal with
  | H : (_ * _)%type |- _ => destruct_product_hypothesis H H
  | H : unit |- _ => destruct H
  end.
Ltac iTypeOfGoal := match goal with |- envs_entails _ ?Δ => Δ end.

Tactic Notation "iModStrict" open_constr(iH) "as" constr(iG) :=
  iDestructCore iH as false (fun H => iModCore H as H; last iDestructHyp H as iG).
Tactic Notation "iDestructStrict" open_constr(iH) "as" constr(iG) :=
  iDestructCore iH as false (fun H => iDestructHyp H as iG).

Ltac iTypeOf' iH :=
  let a := iTypeOf iH in
  match a with
  | Some (_, ?b) => b
  end.

(** Solve [Persistent]/[Timeless] assumptions. *)
Ltac ex_t_solve_persistent :=
  intro_adt_params;
  rewrite /TCNoResolve; intros; prepare_initial_coq_context; apply _.
Ltac ex_t_solve_timeless :=
  intro_adt_params;
  rewrite /TCNoResolve; intros; prepare_initial_coq_context; apply _.

(** Solve the sharing assumption *)
Definition SHELVED_ASSUM `{!typeGS Σ} (P : iProp Σ) := P.
Global Typeclasses Opaque SHELVED_ASSUM.
Global Arguments SHELVED_ASSUM : simpl never.
Lemma shelve_assum `{!typeGS Σ} (P : iProp Σ) :
  P -∗ SHELVED_ASSUM P.
Proof. rewrite /SHELVED_ASSUM. auto. Qed.

Lemma ex_t_lft_solve_sublist_test1 (l : list lft) :
  [] ⊆ l.
Proof. set_solver; solve[fail]. Abort.
Lemma ex_t_lft_solve_sublist_test2 (l1 l3 l : list lft) :
  l ⊆ (l1 ++ l ++ l3).
Proof. set_solver; solve[fail]. Abort.
Lemma ex_t_lft_solve_sublist_test3 (l1 l3 l : list lft) :
  l3 ⊆ (l1 ++ l ++ l3).
Proof. set_solver; solve[fail]. Abort.

Ltac ex_t_destruct_bor :=
  iSelect (&{_} (_))%I (fun iH =>
    let ty := iTypeOf' iH in
    iRename iH into "__H0";
    lazymatch ty with
    | (&{_} (?P))%I =>
      lazymatch P with
      | (_ ∗ _)%I =>
        iModStrict (bor_sep with ("LFT __H0")) as "(? & ?)";
        [done | ]
      | (bi_exist ?Φ)%I =>
        iModStrict (bor_exists_tok with ("LFT __H0 Htok1")) as "(% & __H0 & Htok1)";
        [done | ]
      | (⌜?ϕ⌝)%I =>
          iModStrict (bor_persistent with ("LFT __H0 Htok1")) as ("(>% & Htok1)");
          [done | ]
      | (?l ◁ₗ[?π, Owned true] ?r @ (◁ ?ty))%I =>
          iApply (ltype_own_ofty_share_tac with "[$] [Htok1] [Htok] __H0");
          [ done
          | 
          | iFrame
          | iFrame
          | ];
          [repeat rewrite ty_lfts_unfold/=; set_solver | ];
          iIntros "!> Htok1 Htok";
          iApply fupd_logical_step
      | (?l ◁ₗ[?π, Owned false] ?r @ (◁ ?ty))%I =>
          idtac "solve_shr: cannot share [Owned false] ownership, consider using [Owned true] instead"
      | _ =>
        first
        [ let _ := constr:(_ : Persistent P) in
          iModStrict (bor_persistent with ("LFT __H0 Htok1")) as ("(__H0 & Htok1)");
          [done | ];
          first [ iDestruct "__H0" as ">?" | iDestruct "__H0" as "?" ]
        | idtac "solve_shr: do not know how to share " P ", discarding";
          iPoseProof (shelve_assum with "__H0") as "?"
        ]
      end
    end
  ).

Ltac ex_t_intros_after_logstep :=
  repeat match goal with
  | |- envs_entails _ (_ -∗ _)%I =>
      (* lhs is the actual ownership, rhs are the lifetime tokens *)
      iIntros "(? & ? & ?)"
  end.

Ltac ex_t_merge_lft_tokens' κ frac :=
  iSelect (frac.[κ])%I (fun H =>
    iRevert H;
    first [
      (* try to find the matching partner *)
      iSelect (frac.[κ])%I (fun H =>
        once(
        iIntros "__H0";
        iRename H into "__H1";
        iCombine ("__H0 __H1") as "__H0"))
    | (* no matching partner found, find a smaller fraction first *)
       ex_t_merge_lft_tokens' κ constr:((frac / 2)%Qp);
       (* this was recursively constructed, now find it *)
       iSelect (frac.[κ])%I (fun H =>
        iRename H into "__H1";
        iIntros "__H0";
        iCombine ("__H0 __H1") as "__H0")
    ]
  ).
Ltac ex_t_merge_lft_tokens tokty ident :=
  lazymatch tokty with
  | (?q.[?κ])%I =>
    first [
      (* check if it is already complete *)
      iSelect (q.[κ])%I (fun H => iRename H into ident)
    | (* otherwise, merge *)
      ex_t_merge_lft_tokens' κ constr:((q/2)%Qp);
      iRename "__H0" into ident
    ]
  end.

(** Hook for proving the shared predicate after having shared all the assumptions *)
Ltac ex_plain_t_solve_shr_solve_hook :=
  unshelve (repeat iExists _;
  iFrame "%∗";
  try done;
  rewrite -!guarded_intro;
  iFrame);
  try apply inhabitant
. (* TODO generalize *)

Ltac ex_plain_t_solve_shr :=
  simpl;
  intro_adt_params;
  iIntros (???????); 
  simpl in *;
  prepare_initial_coq_context;
  iIntros "#(LFT & TIME & LLCTX) Htok Hb";
  iEval (rewrite -lft_tok_sep) in "Htok";
  iDestruct "Htok" as "(Htok1 & Htok)";
  let ty_of_Htok1 := iTypeOf' "Htok1" in
  let ty_of_Htok := iTypeOf' "Htok" in
  iApply fupd_logical_step;
  repeat ex_t_destruct_bor;
  unfold SHELVED_ASSUM;
  iApply logical_step_intro;
  iIntros "!>";
  ex_t_intros_after_logstep;
  simpl;
  ex_t_merge_lft_tokens ty_of_Htok1 "Htok1";
  ex_t_merge_lft_tokens ty_of_Htok "Htok";
  iSplitR "Htok1 Htok";
  [ ex_plain_t_solve_shr_solve_hook
  | iCombine "Htok1 Htok" as "Htok"; iEval (rewrite lft_tok_sep) in "Htok"; iApply "Htok"
  ].

(** Solve the monotonicity assumption. *)
Ltac handle_monotonicity_prim iH :=
  let ty := iTypeOf' iH in
  match ty with
  | (_ ◁ₗ[_, Shared _] _ @ _)%I =>
      iApply (ltype_rules.ltype_own_shr_mono with "[]");
      [ | iApply iH];
      done (* TODO: generalize? *)
  | (guarded _)%I =>
      iApply (guarded_mono with "[] " +:+ iH);
      iIntros "__H0";
      handle_monotonicity_prim "__H0"
  | (⌜_⌝)%I => iApply iH
  |  _ => iApply iH
  end.

Ltac prove_assumption_monotonicity iH :=
  let ty := iTypeOf' iH in
  lazymatch ty with
  | (_ ∗ _)%I =>
      iDestructStrict iH as ("( __H0 & " +:+ iH +:+ ")");
      iSplitL "__H0";
      [handle_monotonicity_prim "__H0" | ]
  | (bi_exist ?Φ)%I =>
      let a := fresh "_x" in
      iDestruct iH as (a) iH;
      iExists a
  | _ => handle_monotonicity_prim iH
  end.

Ltac ex_plain_t_solve_shr_mono :=
  simpl;
  intro_adt_params;
  iIntros (?????); prepare_initial_coq_context;
  iIntros "#Hincl"; iIntros "Ha";
  rewrite -?bi.sep_assoc;
  repeat prove_assumption_monotonicity "Ha".

(*
Module test.
  Context `{!typeGS Σ}.

  (* The subtype of positive integers *)
  Local Definition P_a := λ (x : Z) (y : Z), (∃ z : Z, ⌜x = (y + z)%Z⌝ ∗ ⌜(0 < x)%Z⌝)%I : iProp Σ.
  Local Program Definition Pdef := mk_pers_ex_inv_def id P_a _ _.
  Next Obligation. ex_t_solve_persistent. Qed.
  Next Obligation. ex_t_solve_timeless. Qed.
  Local Definition Pty := (∃; Pdef, int i32)%I.

  Local Definition P_b := λ (π : thread_id) (x : Z) (y : Z), (∃ (z : Z) (l : loc), ⌜x = (y + z)%Z⌝ ∗ ⌜(0 < x)%Z⌝ ∗ l ◁ₗ[π, Owned true] #42%Z @ (◁ int i32))%I : iProp Σ.
  Local Definition S_b := λ (π : thread_id) (κ : lft) (x : Z) (y : Z), (∃ (z : Z) (l : loc), ⌜x = (y + z)%Z⌝ ∗ ⌜(0 < x)%Z⌝ ∗ guarded (l ◁ₗ[π, Shared κ] #42%Z @ (◁ int i32)))%I : iProp Σ.

  Local Program Definition Adef := mk_ex_inv_def id P_b S_b [] [] _ _ _.
  Next Obligation. ex_t_solve_persistent. Qed.
  Next Obligation. rewrite /S_b. ex_plain_t_solve_shr_mono. Qed.
  Next Obligation. rewrite /P_b. ex_plain_t_solve_shr. Qed.
End test.
*)

