From refinedrust Require Import type generics existentials.
From iris.proofmode Require Import coq_tactics reduction string_ident.
From refinedrust Require Import int.

(** ** Automation for solving obligations generated by defining existential types for sharing etc.*)
(** Currently tailored specifically to our needs.
   TODO In future, it might be more robust to instantiate Diaframe for this. *)

Ltac intro_adt_params :=
  repeat match goal with
         | |- ∀ _ : prod_vec lft _, _ => intros _
         | |- ∀ _ : plist type _, _ => intros _
         | |- ∀ _ : nil_unit, _ => intros _
         | |- ∀ _ : lft, _ => intros ?
         | |- ∀ _ : type _, _ => intros ?
         | |- ∀ _ : cons_prod _ _, _ => intros _
  end.

(* Recursively destruct a product in hypothesis H, using the given name as template. *)
Ltac destruct_product_hypothesis name H :=
  match goal with
  | H : (_ * _)%type |- _ => let tmp1 := fresh name in
                      let tmp2 := fresh name in
                      destruct H as [tmp1 tmp2];
                      destruct_product_hypothesis name tmp1;
                      destruct_product_hypothesis name tmp2
  |           |- _ => idtac
  end.

Local Ltac prepare_initial_coq_context :=
  (* The automation assumes that all products in the context are destructed, see liForall *)
  repeat lazymatch goal with
  | H : (_ * _)%type |- _ => destruct_product_hypothesis H H
  | H : unit |- _ => destruct H
  end.

(** ** Solve [Persistent]/[Timeless] assumptions. *)
Ltac ex_t_solve_persistent :=
  simpl;
  intro_adt_params;
  rewrite /TCNoResolve; intros; prepare_initial_coq_context; apply _.
Ltac ex_t_solve_timeless :=
  simpl;
  intro_adt_params;
  rewrite /TCNoResolve; intros; prepare_initial_coq_context; apply _.

(** Solve the monotonicity assumption. *)
Class AsShared `{!typeGS Σ} (κ : lft) (P : iProp Σ) := {
  as_shared_pred : lft → iProp Σ;
  as_shared_to_pred : P ⊢ as_shared_pred κ;
}.
Global Hint Mode AsShared + + + + : typeclass_instances.
Class ShareMono `{!typeGS Σ} (Φ : lft → iProp Σ) := {
  share_mono κ κ' :
    κ' ⊑ κ -∗ Φ κ -∗ Φ κ';
}.
Global Hint Mode ShareMono + + + : typeclass_instances.


Ltac iTypeOf' iH :=
  let a := iTypeOf iH in
  match a with
  | Some (_, ?b) => b
  end.

Ltac ex_plain_t_solve_shr_mono :=
  simpl;
  intro_adt_params;
  let κ := fresh "κ" in
  let κ' := fresh "κ'" in
  iIntros (? κ κ' ??);
  prepare_initial_coq_context;
  simpl;
  iIntros "#Hincl"; iIntros "Ha";
  rewrite -?bi.sep_assoc;
  let ty := iTypeOf' "Ha" in
  lazymatch ty with
  | ?P =>
      let as_shr := constr:(_ : AsShared κ P) in
      iApply (share_mono (Φ := as_shr.(as_shared_pred)) with "[]");
      [ | iApply "Ha"];
      done
  end
.



(** ** Solve the sharing assumption *)
Ltac iTypeOfGoal := match goal with |- envs_entails _ ?Δ => Δ end.

Definition SHELVED_ASSUM `{!typeGS Σ} (P : iProp Σ) := P.
Global Typeclasses Opaque SHELVED_ASSUM.
Global Arguments SHELVED_ASSUM : simpl never.
Lemma shelve_assum `{!typeGS Σ} (P : iProp Σ) :
  P -∗ SHELVED_ASSUM P.
Proof. rewrite /SHELVED_ASSUM. auto. Qed.

Lemma ex_t_lft_solve_sublist_test1 (l : list lft) :
  [] ⊆ l.
Proof. set_solver; solve[fail]. Abort.
Lemma ex_t_lft_solve_sublist_test2 (l1 l3 l : list lft) :
  l ⊆ (l1 ++ l ++ l3).
Proof. set_solver; solve[fail]. Abort.
Lemma ex_t_lft_solve_sublist_test3 (l1 l3 l : list lft) :
  l3 ⊆ (l1 ++ l ++ l3).
Proof. set_solver; solve[fail]. Abort.

(** Find a full borrow in the context and destruct/share it.
  Assumes there is a lifetime token "Htok1" for [κ] in the Iris context.
  Assumes there is a lifetime token "Htok" for [lft_intersect_list κs] in the Iris context.
  The goal needs to be a logical_step.
  Transforms to a new goal of the shape
    q.[κ] -∗ q.[lft_intersect_list κs] -∗ logical_step ...
*)
Ltac ex_t_destruct_bor π κ κs iH :=
  let ty := iTypeOf' iH in
  iRename iH into "__H0";
  lazymatch ty with
  | (&{_} (?P))%I =>
    lazymatch P with
    | (?l ◁ₗ[?π, Owned false] ?r @ (◁ ?ty))%I =>
        idtac "solve_shr: cannot share [Owned false] ownership, consider using [Owned true] instead"
    | _ =>
      first
      [ (* check if we have declared how to share it *)
        let SHR := constr:(_ : Shareable π κ κs P) in
        iApply (SHR.(shareable_proof) with "[$] [$] Htok1 Htok __H0");
        [ done | ]
      | (* otherwise discard (putting a wrapper so we don't consider it again) *)
        fail "solve_shr: do not know how to share " P
      ]
    end
  end
  .

(** Hook for proving the shared predicate after having shared all the assumptions *)
Ltac ex_plain_t_solve_shr_solve_hook :=
  (* rewrite with right_id in order to remove True from extra discarded assumptions *)
  rewrite ?right_id; done
.

Ltac ex_plain_t_solve_shr :=
  simpl;
  intro_adt_params;
  let π := fresh "π" in
  let κ := fresh "κ" in
  iIntros (? π κ ????);
  simpl in *;
  prepare_initial_coq_context;
  iIntros "#(LFT & LLCTX) #Hna Htok Hb";
  iEval (rewrite -lft_tok_sep) in "Htok";
  iDestruct "Htok" as "(Htok1 & Htok)";
  let ty_of_Htok1 := iTypeOf' "Htok1" in
  let ty_of_Htok := iTypeOf' "Htok" in
  let κs :=
    match ty_of_Htok with
    | (_.[lft_intersect_list ?κs])%I =>
      constr:(κs)
    | (_.[static])%I =>
      constr:([] : list lft)
    end
  in
  iApply fupd_logical_step;
  ex_t_destruct_bor π κ κs "Hb";
  unfold SHELVED_ASSUM;
  iApply logical_step_intro;
  iIntros "!>";
  iIntros "(? & Htok1 & Htok)";
  simpl;
  iSplitR "Htok1 Htok";
  [ ex_plain_t_solve_shr_solve_hook
  | iCombine "Htok1 Htok" as "Htok"; iEval (rewrite lft_tok_sep) in "Htok"; iApply "Htok"
  ].

Ltac ex_plain_t_solve_shr_auto :=
  simpl; intro_adt_params;
  rewrite /TCNoResolve;
  intros; prepare_initial_coq_context;
  apply _.

(** Instances *)
Global Program Instance sep_as_shared `{!typeGS Σ} (P1 P2 : iProp Σ) κ :
  AsShared κ P1 →
  AsShared κ P2 →
  AsShared κ (P1 ∗ P2)%I := λ HP1 HP2,
  {| as_shared_pred κ := (HP1.(as_shared_pred) κ ∗ HP2.(as_shared_pred) κ)%I |}.
Next Obligation.
  iIntros (????? [? Hshr1] [? Hshr2]) "(P1 & P2)".
  iPoseProof (Hshr1 with "P1") as "$".
  iPoseProof (Hshr2 with "P2") as "$".
Qed.
Global Program Instance sep_share_mono `{!typeGS Σ} (Φ1 Φ2 : lft → iProp Σ) :
  ShareMono Φ1 →
  ShareMono Φ2 →
  ShareMono (λ κ, Φ1 κ ∗ Φ2 κ)%I.
Next Obligation.
  iIntros (???? [Hmono1] [Hmono2] ??) "#Hincl [H1 H2]".
  iPoseProof (Hmono1 with "Hincl H1") as "$".
  iApply (Hmono2 with "Hincl H2").
Qed.
Global Program Instance sep_shareable `{!typeGS Σ} π κ κs (P1 P2 : iProp Σ) :
  Shareable π κ κs P1 →
  Shareable π κ κs P2 →
  Shareable π κ κs (P1 ∗ P2)%I := λ Shr1 Shr2, {|
    shareable_prop := (Shr1.(shareable_prop) ∗ Shr2.(shareable_prop))%I
  |}.
Next Obligation.
  iIntros (??????? [? Hshr1] [? Hshr2]).
  iIntros (?? q ?) "[#LFT #LLCTX] #Hna [Htok11 Htok12] [Htok1 Htok2] Hb HT".
  iApply fupd_logical_step.
  iMod (bor_sep with "LFT Hb") as "(Hb1 & Hb2)"; first done.
  iApply (Hshr1 with "[$LFT $LLCTX] Hna Htok11 Htok1 Hb1"); first done.
  iApply (Hshr2 with "[$LFT $LLCTX] Hna Htok12 Htok2 Hb2"); first done.
  iApply (logical_step_wand with "HT").
  iModIntro.
  iIntros "HT (? & ? & ?) (?& ? & ?)".
  iApply "HT". iFrame.
Qed.

Global Program Instance exist_as_shared `{!typeGS Σ} {A} (Φ : A → iProp Σ) κ :
  (∀ x : A, AsShared κ (Φ x)) →
  AsShared κ (∃ x : A, Φ x)%I := λ HP,
  {| as_shared_pred κ := (∃ x : A, (HP x).(as_shared_pred) κ)%I |}.
Next Obligation.
  iIntros (????? Hshr) "(%x & HP)".
  iExists x. by iApply as_shared_to_pred.
Qed.
Global Program Instance exist_share_mono `{!typeGS Σ} {A} (Φ : lft → A → iProp Σ) :
  (∀ x : A, ShareMono (λ κ, Φ κ x)) →
  ShareMono (λ κ, ∃ x : A, Φ κ x)%I.
Next Obligation.
  iIntros (???? Hshr ??) "Hincl (%x & Ha)".
  iExists x.
  destruct (Hshr x) as [Hshr'].
  iApply (Hshr' with "Hincl Ha").
Qed.
Global Program Instance exist_shareable `{!typeGS Σ} π κ κs {A} (Φ : A → iProp Σ) :
  (∀ x, Shareable π κ κs (Φ x)) →
  Shareable π κ κs (∃ x : A, Φ x) := λ Shr, {|
    shareable_prop := (∃ x : A, (Shr x).(shareable_prop))%I
  |}.
Next Obligation.
  iIntros (??????? Shr ????) "[#LFT #LCTX] #Hna Htok Htok1 Hb HT".
  iApply fupd_logical_step.
  iMod (bor_exists_tok with "LFT Hb Htok") as "(%x & Hb & Htok)"; first done.
  iApply ((Shr x).(shareable_proof) with "[$LFT $LCTX] Hna Htok Htok1 Hb"); first done.
  iApply (logical_step_wand with "HT").
  iModIntro. iIntros "HT (? & ? & ?)".
  iApply "HT". iFrame.
Qed.

(* Fallback *)
Global Program Instance as_shared_fallback `{!typeGS Σ} κ (P : iProp Σ) :
  AsShared κ P | 1000 := {| as_shared_pred κ := P |}.
Next Obligation.
  done.
Qed.
Global Program Instance share_mono_trivial `{!typeGS Σ} (P : iProp Σ) :
  ShareMono (λ _, P).
Next Obligation.
  intros. eauto.
Qed.
Global Program Instance persistent_shareable `{!typeGS Σ} π κ κs (P : iProp Σ) `{!Persistent P} :
  Shareable π κ κs P := {| shareable_prop := P |}.
Next Obligation.
  iIntros (???????????) "[#LFT #LCTX] #Hna Htok Htok1 Hb HT".
  iApply fupd_logical_step.
  iMod (bor_persistent with "LFT Hb Htok") as "(HP & Htok)"; first done.
  iApply (logical_step_compose with "HT").
  iApply logical_step_intro_later.
  iModIntro. iNext. iIntros "HT". iApply "HT". iFrame.
Qed.

(** Can be declared as instances to discard unshareable props *)
Program Definition shareable_discard `{!typeGS Σ} (P : iProp Σ) π κ κs :
  Shareable π κ κs P := {| shareable_prop := True |}.
Next Obligation.
  iIntros (??????????) "#CTX #Hna Htok Htok1 Hb HT".
  iApply (logical_step_wand with "HT").
  iIntros "HT". iApply "HT".
  iFrame.
Qed.

Global Instance shareable_discard_freeable `{!typeGS Σ} π κ κs l n q al :
  Shareable π κ κs (freeable l n q al) := shareable_discard _ _ _ _.
Global Instance shareable_discard_freeable_nz `{!typeGS Σ} π κ κs l n q al :
  Shareable π κ κs (freeable_nz l n q al) := shareable_discard _ _ _ _.

Global Program Instance guarded_as_shared `{!typeGS Σ} P κ :
  AsShared κ P →
  AsShared κ (guarded P) := λ HP,
  {| as_shared_pred κ := guarded (HP.(as_shared_pred) κ) |}.
Next Obligation.
  iIntros (???? [? Hshr]).
  iApply guarded_mono.
  iIntros "HP". by iApply Hshr.
Qed.
Global Program Instance guarded_share_mono `{!typeGS Σ} Φ :
  ShareMono Φ → ShareMono (λ κ, guarded (Φ κ)).
Next Obligation.
  iIntros (??? [Hmono] ??) "Hincl Ha".
  iApply (guarded_mono with "[Hincl] Ha").
  by iApply Hmono.
Qed.

Global Program Instance big_sepL_as_shared `{!typeGS Σ} κ {A} (xs : list A) (Φ : nat → A → iProp Σ) :
  (∀ i x, AsShared κ (Φ i x)) →
  AsShared κ ([∗ list] i ↦ x ∈ xs, Φ i x)%I := λ ToShr,
  {| as_shared_pred κ := ([∗ list] i ↦ x ∈ xs, (ToShr i x).(as_shared_pred) κ)%I; |}.
Next Obligation.
  iIntros (?????? ToShr). simpl.
  iApply big_sepL_mono.
  iIntros (i x Hlook).
  apply as_shared_to_pred.
Qed.
Global Program Instance big_sepL_share_mono `{!typeGS Σ} {A} (xs : list A) (Φ : lft → nat → A → iProp Σ) :
  (∀ i x, ShareMono (λ κ, Φ κ i x)) →
  ShareMono (λ κ, ([∗ list] i ↦ x ∈ xs, Φ κ i x))%I.
Next Obligation.
  iIntros (????? Hshr ??) "#Hincl Ha".
  iApply (big_sepL_impl with "Ha").
  iModIntro. iIntros (i x Hlook).
  iApply ((Hshr i x).(share_mono) with "Hincl").
Qed.
Global Program Instance big_sepL_shareable `{!typeGS Σ} π κ κs {A} (xs : list A) (Φ : nat → A → iProp Σ) :
  (∀ i x, Shareable π κ κs (Φ i x)) →
  Shareable π κ κs ([∗ list] i ↦ x ∈ xs, Φ i x) := λ Shr, {|
    shareable_prop := ([∗ list] i ↦ x ∈ xs, (Shr i x).(shareable_prop))%I;
  |}.
Next Obligation.
  iIntros (?????? xs Φ Shr F G q ?) "#[LFT LLCTX] #Hna Htok Htok1 Hb HT".
  (* fracture the tokens *)
  set (len := length xs).
  iCombine ("Htok Htok1") as "Htok".
  iEval (rewrite lft_tok_sep) in "Htok".
  iPoseProof (Fractional_split_big_sepL (λ q, q.[_]%I) len with "Htok") as "(%qs & %Hlen' & Htoks & Hcl_toks)".
  set (κ' := κ ⊓ lft_intersect_list κs).

  iApply fupd_logical_step.
  iMod (bor_big_sepL with "LFT Hb") as "Hb"; first done.
  iAssert ([∗ list] i ↦ x; q' ∈ xs; qs, &{κ} (Φ i x) ∗ q'.[κ'])%I with "[Htoks Hb]" as "Hb".
  { iApply big_sepL2_sep_sepL_r; iFrame. iApply big_sepL2_const_sepL_l. iSplitR; last done. rewrite Hlen' //. }

  iAssert ([∗ list] i ↦ x; q' ∈ xs; qs, logical_step F ((Shr i x).(shareable_prop) ∗ q'.[κ']))%I with "[Hb]" as "Hb".
  { iApply (big_sepL2_wand with "Hb"). iApply big_sepL2_intro; first by lia.
    iModIntro. iIntros (k x q0 Hlook1 Hlook2) "(Hb & Htok)".
    subst κ'.
    rewrite -{1}lft_tok_sep. iDestruct "Htok" as "(Htok1 & Htok2)".
    iApply (shareable_proof with "[$LFT $LLCTX] Hna Htok1 Htok2 Hb"); first done.
    iApply logical_step_intro.
    rewrite lft_tok_sep. eauto. }
  iPoseProof (logical_step_big_sepL2 with "Hb") as "Hb".
  iModIntro. iApply (logical_step_compose with "Hb").
  iApply (logical_step_wand with "HT").
  iIntros "HT Hb".
  iPoseProof (big_sepL2_sep_sepL_r with "Hb") as "(Hb & Htok)".
  iPoseProof ("Hcl_toks" with "Htok") as "Htok".
  iPoseProof (big_sepL2_const_sepL_l with "Hb") as "(_ & Hb)".
  iApply "HT". rewrite lft_tok_sep. iFrame.
Qed.

Global Program Instance ltype_as_shared `{!typeGS Σ} π κ l {rt} (lt : ltype rt) r :
  AsShared κ (l ◁ₗ[π, Shared κ] r @ lt) :=
  {| as_shared_pred κ := (l ◁ₗ[π, Shared κ] r @ lt)%I; |}.
Next Obligation.
  iIntros (????????). done.
Qed.
Global Program Instance ltype_share_mono `{!typeGS Σ} π l {rt} (lt : ltype rt) r :
  ShareMono (λ κ, l ◁ₗ[π, Shared κ] r @ lt)%I.
Next Obligation.
  iIntros (?????????) "Hincl".
  by iApply ltype_own_shr_mono.
Qed.

Lemma ltype_own_ofty_share `{!typeGS Σ} π F κ q l {rt} (ty : type rt) r :
  lftE ⊆ F →
  rrust_ctx -∗
  na_own π ∅ -∗
  let κ' := lft_intersect_list (ty_lfts ty) in
  q.[κ ⊓ κ'] -∗
  (&{κ} (l ◁ₗ[π, Owned true] r @ ◁ ty)) -∗
  logical_step F ((l ◁ₗ[π, Shared κ] r @ ◁ ty) ∗ q.[κ ⊓ κ']).
Proof.
  iIntros (?) "#(LFT & LLCTX) #Hna Htok Hl".
  iApply fupd_logical_step.
  iEval (rewrite ltype_own_ofty_unfold /lty_of_ty_own) in "Hl".
  rewrite -lft_tok_sep.
  iDestruct "Htok" as "(Htok & Htok2)".
  iMod (bor_exists_tok with "LFT Hl Htok") as "(%ly & Hl & Htok)"; first done.
  iMod (bor_sep with "LFT Hl") as "(Hst & Hl)"; first done.
  iMod (bor_persistent with "LFT Hst Htok") as "(>%Hst & Htok)"; first done.
  iMod (bor_sep with "LFT Hl") as "(Hly & Hl)"; first done.
  iMod (bor_persistent with "LFT Hly Htok") as "(>%Hly & Htok)"; first done.
  iMod (bor_sep with "LFT Hl") as "(Hsc & Hl)"; first done.
  iMod (bor_persistent with "LFT Hsc Htok") as "(>#Hsc & Htok)"; first done.
  iMod (bor_sep with "LFT Hl") as "(Hlb & Hl)"; first done.
  iMod (bor_persistent with "LFT Hlb Htok") as "(>#Hlb & Htok)"; first done.
  iMod (bor_sep with "LFT Hl") as "(Hcred & Hl)"; first done.
  iMod (bor_exists_tok with "LFT Hl Htok") as "(%r' & Hl & Htok)"; first done.
  iMod (bor_sep with "LFT Hl") as "(Hrfn & Hl)"; first done.

  iMod (place_rfn_interp_owned_share with "LFT Hrfn Htok") as "(Hrfn & Htok)"; first done.
  iDestruct "Htok" as "(Htok & Htok1)".
  iMod (bor_acc with "LFT Hcred Htok1") as "(>Hcred & Hcl_cred)"; first done.
  iDestruct "Hcred" as "(Hcred & Hat)".
  iDestruct "Hcred" as "(Hcred1 & Hcred)".
  iMod (bor_later with "LFT Hl") as "Hl"; first done.
  iApply (lc_fupd_add_later with "Hcred1"). iNext. iMod "Hl" as "Hl".
  iMod (bor_fupd_later with "LFT Hl Htok") as "Ha"; [done.. | ].
  iDestruct "Hcred" as "(Hcred1 & Hcred)".
  iApply (lc_fupd_add_later with "Hcred1"). iNext. iMod "Ha" as "(Hl & Htok)".
  iDestruct "Htok2" as "(Htok2 & Htok2')".
  iPoseProof (ty_share _ F with "[$LFT $LLCTX] Hna [Htok Htok2] [//] [//] Hlb Hl") as "Hstep"; [done | ..].
  { rewrite ty_lfts_unfold. rewrite -lft_tok_sep. iFrame. }
  iApply logical_step_fupd.
  iApply (logical_step_compose with "Hstep").
  iApply (logical_step_intro_tr with "Hat").
  iModIntro. iIntros "Hat Hcred' ".
  iModIntro. iIntros "(#Hshr & Htok)".
  iMod ("Hcl_cred" with "[$Hcred' Hat]") as "(Hcred' & Htok1)".
  { iNext. iApply tr_weaken; last done.
    simpl. unfold num_laters_per_step. lia. }
  rewrite ty_lfts_unfold.
  iCombine "Htok1 Htok2'" as "Htok1".
  rewrite !lft_tok_sep. iFrame "Htok Htok1".
  iModIntro. rewrite ltype_own_ofty_unfold /lty_of_ty_own/=.
  iExists _. iR. iR. iR. iR.
  iExists _. iFrame. iModIntro. iModIntro. done.
Qed.

(* TODO : make lft_intersect_list simpl never in the lemmas using this. *)
Lemma ltype_own_ofty_share' `{!typeGS Σ} π F κ κ' q l {rt} (ty : type rt) r :
  lftE ⊆ F →
  (ty_lfts ty) ⊆ κ' →
  rrust_ctx -∗
  na_own π ∅ -∗
  q.[κ] -∗
  q.[lft_intersect_list κ'] -∗
  (&{κ} (l ◁ₗ[π, Owned true] r @ ◁ ty)) -∗
  logical_step F ((l ◁ₗ[π, Shared κ] r @ ◁ ty) ∗ q.[κ] ∗ q.[lft_intersect_list κ']).
Proof.
  iIntros (? Hsub) "#CTX #Hna Htok1 Htok2 Hl".
  iApply fupd_logical_step.
  iMod (lft_incl_acc _ _ (lft_intersect_list (ty_lfts ty)) with "[] Htok2") as "(%q' & Htok2 & Hcltok2)"; first done.
  { iApply list_incl_lft_incl_list. done. }
  set (q0 := Qp.min q q').
  iPoseProof (Fractional_fractional_le (λ q, q.[κ])%I q q0 with "Htok1") as "[Htok1 Hcltok1]".
  { apply Qp.le_min_l. }
  iPoseProof (Fractional_fractional_le (λ q, q.[lft_intersect_list (ty_lfts ty)])%I q' q0 with "Htok2") as "[Htok2 Hcltok2']".
  { apply Qp.le_min_r. }
  iPoseProof (ltype_own_ofty_share with "CTX Hna [Htok1 Htok2] Hl") as "Hstep"; first done.
  { rewrite -lft_tok_sep. iFrame. }
  iApply logical_step_fupd.
  iApply (logical_step_wand with "Hstep").
  rewrite -lft_tok_sep.
  iIntros "!> ($ & Htok1 & Htok2)".
  iPoseProof ("Hcltok1" with "Htok1") as "$".
  iPoseProof ("Hcltok2'" with "Htok2") as "Htok2".
  iMod ("Hcltok2" with "Htok2") as "$". done.
Qed.

Class SolveTyLftIncl `{!typeGS Σ} {rt} (ty : type rt) κs : Prop := solve_ty_lft_incl : ty_lfts ty ⊆ κs.
Hint Extern 1 (SolveTyLftIncl ?ty ?κs) =>
  unfold SolveTyLftIncl; repeat rewrite ty_lfts_unfold/=; set_solver : typeclass_instances
.
Global Hint Mode SolveTyLftIncl + + + + + : typeclass_instances.

Global Program Instance shareable_ltype_own `{!typeGS Σ} π κ κs l {rt} (ty : type rt) r `{!SolveTyLftIncl ty κs} :
  Shareable π κ κs (l ◁ₗ[π, Owned true] r @ (◁ ty))%I := {|
    shareable_prop := guarded (l ◁ₗ[π, Shared κ] r @ (◁ ty))%I
  |}.
Next Obligation.
  iIntros (?? π κ κs l ? ty r Hincl F G q ?) "#CTX Hna Htok1 Htok2 Hl HT".
  unfold SolveTyLftIncl in Hincl.
  iPoseProof (ltype_own_ofty_share' with "CTX Hna Htok1 Htok2 Hl") as "Hstep'"; [done.. | ].
  iApply (logical_step_compose with "HT").
  iApply (logical_step_wand with "Hstep'").
  iIntros "(Ha & ? & ?) Hb". iApply "Hb".
  iFrame. by iApply guarded_intro.
Qed.

